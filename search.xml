<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[P4092]]></title>
    <url>%2F2019%2F10%2F15%2FP4092%2F</url>
    <content type="text"><![CDATA[P4092[HEOI2016/TJOI2016]树（题解）Link.点我 Ready.dfs序：把原树按照dfs的序号编号，先dfs到的节点dfs序小例如下图中就是样例，黑体是dfs序，蓝体是题目给定序（原序） Attention.dfs序与原序要分清修改时并不能直接赋值，要取最大值。 Solution.先把原数赋予按照dfs序，以及逆dfs序。现在经观察得，每一个点的子孙便是【它，它的最右子节点】中所有整数。接下来便可以向线段树思考了，它需要维护区间最大值。支持区间改最大值，查最大值。 Coding.123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117#include&lt;bits/stdc++.h&gt;#define ll long long#define ull unsigned long longusing namespace std;const ll Max=100005;struct data //线段树节点&#123; ll num,flag; data() &#123;num=1;flag=0;&#125; data(ll a,ll b):num(a),flag(b) &#123;&#125;&#125;;struct tree //题目中给的树&#123; vector&lt;ll&gt;b[Max]; ll dfs_xu[Max],ni_dfs_xu[Max],size; inline void clean() //清空 &#123; for(ll i=0;i&lt;Max;i++) b[i].clear(); &#125; inline void add_edge(ll x,ll y) //加边 &#123; b[x].push_back(y); &#125; void dfs(ll now,ll fa) //求dfs序 &#123; if(now==1) size=0; size++; dfs_xu[now]=size; for(ull i=0;i&lt;b[now].size();i++) if(b[now][i]!=fa) dfs(b[now][i],now); &#125; inline void ni_dfs() //求逆dfs序 &#123; for(ll i=1;i&lt;=size;i++) ni_dfs_xu[dfs_xu[i]]=i; &#125; ll rightest(ll n) //n是原序,rightest是原序; &#123; if(b[n].size()==0) return n; return rightest(b[n][b[n].size()-1]); &#125;&#125;;struct cut_tree //线段树&#123; data tre[Max&lt;&lt;2]; inline void down(ll rt,ll l,ll r) //下推标记（有点烦） &#123; if(!tre[rt].flag) return; if(l==r) &#123; tre[rt].num=max(tre[rt].num,tre[rt].flag); //注意！！！不应该直接赋值 tre[rt].flag=0; return; &#125; tre[rt&lt;&lt;1].flag=max(tre[rt].flag,tre[rt&lt;&lt;1].flag); tre[rt&lt;&lt;1|1].flag=max(tre[rt].flag,tre[rt&lt;&lt;1|1].flag); tre[rt].num=max(tre[rt].num,tre[rt].flag); tre[rt].flag=0; &#125; inline void up(ll rt,ll l,ll r) //上推数值 &#123; tre[rt].num=max(tre[rt&lt;&lt;1].num,tre[rt&lt;&lt;1|1].num); &#125; ll csearch(ll rt,ll l,ll r,ll d) //查询 &#123; down(rt,l,r); if(l==d&amp;&amp;r==d) return tre[rt].num; if(d&lt;=(l+r)&gt;&gt;1) return csearch(rt&lt;&lt;1,l,(l+r)&gt;&gt;1,d); return csearch(rt&lt;&lt;1|1,((l+r)&gt;&gt;1)+1,r,d); &#125; void change(ll rt,ll l,ll r,ll dl,ll dr,ll dc) //修改 &#123; if(l&gt;r) return; if(dl&gt;r) return; if(l&gt;dr) return; if(dl&lt;=l&amp;&amp;r&lt;=dr) &#123; tre[rt].flag=max(tre[rt].flag,dc); return; &#125; change(rt&lt;&lt;1,l,(l+r)&gt;&gt;1,dl,dr,dc); change(rt&lt;&lt;1|1,((l+r)&gt;&gt;1)+1,r,dl,dr,dc); up(rt,l,r); &#125;&#125;;cut_tree tr;tree a;int main()&#123; ll n,q; scanf("%lld%lld",&amp;n,&amp;q); a.clean(); for(ll i=1;i&lt;n;i++) &#123; ll x,y; scanf("%lld%lld",&amp;x,&amp;y); a.add_edge(x,y); &#125; a.dfs(1,0); a.ni_dfs(); while(q--) &#123; char c;ll x; cin&gt;&gt;c;scanf("%lld",&amp;x); if(c=='C') &#123; ll y=a.rightest(x); tr.change(1,1,n,a.dfs_xu[x],a.dfs_xu[y],a.dfs_xu[x]); //此处要搞清！！！ &#125; if(c=='Q') &#123; ll y=tr.csearch(1,1,n,a.dfs_xu[x]); printf("%lld\n",a.ni_dfs_xu[y]); //还有此处 &#125; &#125; return 0;&#125;]]></content>
      <tags>
        <tag>线段树</tag>
        <tag>树链剖分</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[P1299]]></title>
    <url>%2F2019%2F10%2F15%2FP1299%2F</url>
    <content type="text"><![CDATA[P1299切孔机（题解）Link.点我 PS:人生中的第一道黑题。（可惜现在掉绿了）发一个题解纪念一下。 Solution.首先先把读入的$\texttt{x},\texttt{y}$离散化把所有的切痕记录下来bfs把孔外的格子找出来数有几个格子。（一个图中有几个连通块） My Coding. xx,yy:表示方向。 point:表示点。 number:第几次切 x,y:切的点的坐标 picture:记录切痕 can_go:一个点可以不可以向上下左右走(0:上,1:下,2:左:右) visit:一个点是不是孔中的点(0:不是,1:是) cmpx,cmpy:离散化时用 cmp:切的次数从小到大，第一个切点尽量左上 ready:读入 lisan:离散化 build_wall:把所有切痕记录下来（2） cut_paper:剪纸，把孔外的格子记录下来（3） count_hole:数有几个洞（4）Coding.123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const ll xx[4]=&#123;-1,1,0,0&#125;,yy[4]=&#123;0,0,-1,1&#125;;struct point&#123; ll number,x,y; point() &#123;&#125; point(ll a,ll b):x(a),y(b) &#123;&#125;&#125;;struct picture&#123; bool can_go[4],visit; picture() &#123; can_go[0]=can_go[1]=can_go[2]=can_go[3]=1; visit=1; &#125;&#125;;ll n;point a[205];picture b[205][205];inline bool cmpx(point a,point b)&#123; return a.x&lt;b.x;&#125;inline bool cmpy(point a,point b)&#123; return a.y&lt;b.y;&#125;inline bool cmp(point a,point b)&#123; if(a.number!=b.number) return a.number&lt;b.number; if(a.x!=b.x) return a.x&lt;b.x; return a.y&lt;b.y;&#125;inline void ready()&#123; scanf("%lld",&amp;n); for(int i=1;i&lt;=n*2;i++) &#123; a[i].number=(i+1)/2; scanf("%lld%lld",&amp;a[i].x,&amp;a[i].y); &#125;&#125;inline void lisan()&#123; ll now,u; now=-10000005; u=0; sort(a+1,a+n*2+1,cmpx); for(ll i=1;i&lt;=n*2;i++) &#123; if(a[i].x!=now) &#123; now=a[i].x; u++; a[i].x=u; &#125; else a[i].x=u; &#125; now=-10000005; u=0; sort(a+1,a+n*2+1,cmpy); for(ll i=1;i&lt;=n*2;i++) &#123; if(a[i].y!=now) &#123; now=a[i].y; u++; a[i].y=u; &#125; else a[i].y=u; &#125;&#125;inline void build_wall()&#123; sort(a+1,a+n*2+1,cmp); for(ll i=1;i&lt;=n;i++) &#123; point s=a[i*2-1],e=a[i*2]; for(ll j=s.x+1;j&lt;=e.x;j++) &#123; b[j][s.y].can_go[3]=0; b[j][s.y+1].can_go[2]=0; &#125; for(ll j=s.y+1;j&lt;=e.y;j++) &#123; b[s.x][j].can_go[1]=0; b[s.x+1][j].can_go[0]=0; &#125; &#125;&#125;inline void cut_paper()&#123; queue&lt;point&gt;q; q.push(point(0,0)); while(!q.empty()) &#123; point now=q.front(); q.pop(); for(int i=0;i&lt;4;i++) &#123; ll x=now.x+xx[i],y=now.y+yy[i]; if(x&lt;0||x&gt;200||y&lt;0||y&gt;200) continue; if(!b[x][y].visit) continue; if(!b[now.x][now.y].can_go[i]) continue; b[x][y].visit=0; q.push(point(x,y)); &#125; &#125;&#125;inline void bfs(ll dx,ll dy)&#123; queue&lt;point&gt;q; b[dx][dy].visit=0; q.push(point(dx,dy)); while(!q.empty()) &#123; point now=q.front(); q.pop(); for(int i=0;i&lt;4;i++) &#123; ll x=now.x+xx[i],y=now.y+yy[i]; if(x&lt;0||x&gt;200||y&lt;0||y&gt;200) continue; if(!b[x][y].visit) continue; b[x][y].visit=0; q.push(point(x,y)); &#125; &#125;&#125;inline ll count_hole()&#123; ll ans=0; for(ll i=0;i&lt;=200;i++) for(ll j=0;j&lt;=200;j++) &#123; if(!b[i][j].visit) continue; ans++; bfs(i,j); &#125; return ans;&#125;int main()&#123; ready(); lisan(); build_wall(); cut_paper(); ll ans=count_hole(); printf("%lld\n",ans); return 0;&#125;]]></content>
      <tags>
        <tag>离散化</tag>
        <tag>搜索</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[P1485]]></title>
    <url>%2F2019%2F10%2F15%2FP1485%2F</url>
    <content type="text"><![CDATA[P1485火枪打怪（题解）Link.点我 PS.此题第一眼就可以看出是二分答案我看了标签QwQ Solution.最难的是二分的$\texttt{check}$函数如何写。首先因为子弹的威力是定值，所以每一个子弹的溅射范围是一样的，事先算出溅射范围。$\texttt{p-(i-j)}\times\texttt{(i-j)}=\texttt{p-i}^\texttt{2}+\texttt{2}\times\texttt{i}\times\texttt{j+j}^\texttt{2}$这个式子中，$\texttt{i}^\texttt{2}$、$\texttt{2}\times\texttt{i}\times\texttt{j}$、$\texttt{j}^\texttt{2}$ 都是可以维护的。于是我们维护$\texttt{i}^\texttt{2}$之和，$\texttt{2}\times\texttt{i}$之和，$\texttt{1}$之和。在加入时可以临时乘上$\texttt{j}$的次方次幂。 Coding.1234567891011121314151617181920212223242526272829303132333435363738394041#include&lt;bits/stdc++.h&gt;#define ll long long#define int long longusing namespace std;int n,k,b[500005];ll a[500005];inline char check(ll p)&#123; ll _2=0,_1=0,_0=0,s=sqrt(p)+1; //s表示溅射范围，_2，_1，_0分别表示 i*i ， 2*i ， 1 。 int tot=0; //tot表示子弹数。 memset(b,0,sizeof(b)); //b表示在这里有无发过子弹。 for(int i=n;i&gt;=1;i--) &#123; if(i+s&lt;=n&amp;&amp;b[i+s]) _2-=(i+s)*(i+s)*b[i+s],_1-=(i+s)*b[i+s],_0-=b[i+s]; //溅射结束，去掉影响。 ll gone=_0*p-_0*i*i+2*_1*i-_2; //gong表示这个怪物由于之前的溅射扣的血量。 if(a[i]&gt;=gone) b[i]=(a[i]-gone)/p+1,tot+=b[i],_0+=b[i],_1+=b[i]*i,_2+=b[i]*i*i; //如果这个怪物没被打死，还需要在开枪。 if(tot&gt;k) return 1; //k枪已经打不死全部怪物了。 &#125; return 0;&#125;signed main()&#123; scanf("%lld%lld",&amp;n,&amp;k); for(int i=1;i&lt;=n;i++) scanf("%lld",a+i); ll l=1,r=1e13,ans=0; while(l&lt;=r) &#123; int mid=(l+r)&gt;&gt;1; if(check(mid)) l=mid+1;else r=mid-1,ans=mid; &#125; //二分板子。 printf("%lld\n",ans); return 0;&#125;]]></content>
      <tags>
        <tag>二分答案</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[P1863]]></title>
    <url>%2F2019%2F10%2F15%2FP1863%2F</url>
    <content type="text"><![CDATA[P1863独眼兔（题解）Link.点我]] PS.此题是计算几何的入门好题，但是我却拖了大概两个月才把它搞定。。。心情十分激动，于是来写一篇题解纪念一下QwQ。楼上的那一篇题解都用蒟蒻我看不懂的虚数，所以这篇题解很少用用STL的东西 Ready.1.向量是什么 2.向量怎么表示 3.向量的产生设$\texttt{A(x}_\texttt{1}\texttt{,y}_\texttt{1}\texttt{) B(x}_\texttt{2}\texttt{,y}_\texttt{2}\texttt{)}$则$\overrightarrow{\texttt{AB}}=\texttt{(x}_\texttt{2}\texttt{-x}_\texttt{1}\texttt{,y}_\texttt{1}\texttt{-y}_\texttt{2}\texttt{)}$ 4.向量的叉积设$\overrightarrow{\texttt{a}}\texttt{=(x}_\texttt{1}\texttt{,y}_\texttt{1}\texttt{)}\overrightarrow{\texttt{b}}\texttt{ =(x}_\texttt{2}\texttt{,y}_\texttt{2}\texttt{)}$$\texttt{|}\overrightarrow{\texttt{a}}\times\overrightarrow{\texttt{b}}\texttt{|=}\sin\texttt{}\times\texttt{|a|}\times\texttt{|b|}$$\texttt{=x}_\texttt{\texttt{1}}\texttt{y}_\texttt{2}\texttt{-x}_\texttt{2}\texttt{y}_\texttt{1}$$\boxed{\color{white}\colorbox{red}{注意：向量的叉积是一个向量，但是由于它飞出了平面，我们只考虑它的模长。}}$由于$\texttt{|}\overrightarrow{\texttt{a}}\times\overrightarrow{\texttt{b}}\texttt{|=}\sin\texttt{}\times\texttt{|a|}\times\texttt{|b|}$，所以向量的叉积的绝对值可以表示两个向量所夹的三角形面积，向量的叉积的正负可以表示两个向量的旋转的方向。 Example. Solution.总体思路是： 首先应该先找出最下面的点。 然后一个一个的去找点，找到最优的点。 最后输出答案。但是如何去找到最优的点呢？ 首先如果这个点从上一个点来需要向右旋转，那肯定不可能，这里需要用向量叉积的正负性。 然后用贪心的思想，尽量找到旋转角度最小的点，这里需要用向量叉积的模长。Coding.1234567891011121314151617181920212223242526272829303132333435363738394041#include&lt;bits/stdc++.h&gt;using namespace std;const int INF=1000000005;struct vec&#123; int x,y; inline vec operator+(vec &amp;b) const &#123;return (vec)&#123;x+b.x,y+b.y&#125;;&#125; //向量加 inline vec operator-(vec &amp;b) const &#123;return (vec)&#123;x-b.x,y-b.y&#125;;&#125; //向量减&#125;; //向量结构体inline int operator*(vec a,vec b) &#123;return a.x*b.y-a.y*b.x;&#125; //向量的叉积struct point&#123; int x,y; inline vec operator-(point &amp;b) const &#123;return (vec)&#123;x-b.x,y-b.y&#125;;&#125; //向量产生 inline double operator/(point &amp;b) const &#123;return sqrt((x-b.x)*(x-b.y)+(y-b.y)*(y-b.y));&#125; //两点之间的距离&#125;a[1005];//平面上的一个点int n,w=0,vis[1005]; //vis表示此处的萝卜是否被吃掉了vector&lt;int&gt;v; //v表示答案数组int main()&#123; scanf("%d",&amp;n),a[0].x=a[0].y=INF; //第一个点设置为无穷大，是为了方便下一行处理 for(int i=1;i&lt;=n;i++) scanf("%d%d",&amp;a[i].x,&amp;a[i].y),w=(a[i].y&lt;a[w].y)?i:w; memset(vis,0,sizeof(vis)); vis[w]=1,v.push_back(w); //最下面的点入队 point lst1=(point)&#123;0,a[w].y&#125;,lst2=a[w]; //lst1表示上一个点，lst2表示前面的第二个点 for(int i=1,mw=-1;i&lt;n;i++,mw=-1) &#123; for(int j=1;j&lt;=n;j++) if(!vis[j]&amp;&amp;(lst2-lst1)*(a[j]-lst1)&gt;=0) //这个点没有来过且不需要享有旋转 &#123; if(mw==-1) &#123;mw=j;continue;&#125; int t=(a[mw]-lst2)*(a[j]-lst2); //用贪心的思想，要尽量的找到与上一个面积最小 if(t&lt;0||(t==0&amp;&amp;(a[j]/lst2)&lt;(a[mw]/lst2))) mw=j; &#125; if(mw==-1) break; v.push_back(mw),vis[mw]=1,lst1=lst2,lst2=a[mw]; //加入答案序列，标位已访问 &#125; printf("%d ",n); for(int i=0;i&lt;(int)v.size();i++) printf("%d ",v[i]); //输出 return puts(""),0;&#125;]]></content>
      <tags>
        <tag>计算几何</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[P4906小奔关闹钟（题解）]]></title>
    <url>%2F2019%2F10%2F15%2FP4906%2F</url>
    <content type="text"><![CDATA[P4906 小奔关闹钟Link.点我 PS.暂无 Problem. 目标：关闭所有的电灯 特殊：关了一个点灯之后，会影响其他电灯的开闭，其他点灯的开闭又继续影响 限制：上面的影响只会持续2轮，不要问我为什么，我是从样例中看出来的QwQSolution.由于题意分析中的第三条，我们可以考虑初始化更改一个点灯的状态后会产生的影响。复杂度是$\texttt{O(n}^\texttt{3}\texttt{)}$，对于$\texttt{1&lt;n&lt;20}$的数据一定能过。然后就可以暴力$\texttt{dfs}$来求答案了。当然，如果两次或多次关同一盏灯，那么开关的效果会被抵消，所以对于每一个点，只有动与不动两种情况。所以$\texttt{dfs}$的复杂度是$\texttt{O(2}^\texttt{n}\texttt{)}$，能过。Attention.由于$\texttt{n&lt;=20}$，$\texttt{2}^\texttt{20}=1048576$，在$\texttt{int}$的数据范围内，所以我们可以考虑状压。由于开灯与关灯具有如下性质：$\texttt{0+0=0,1+1=0,0+1=1,1+0=0}$，所以我们可以把它当成异或操作。Coding.代码里有解释123456789101112131415161718192021222324252627282930313233343536373839#include&lt;bits/stdc++.h&gt;#define ya(x) (1&lt;&lt;(x)) //状压函数，把一个集合压成一个数字#define go(x,y) ((x)!=(y)&amp;&amp;a[(x)][(y)]) //判断函数：这里有一个坑点，就是一盏灯自己会指向自己，要加一个特判using namespace std;const int N=25,INF=1000000007;int n,m,ans,cha[N];char a[N][N];inline int dfs(int x,int s)&#123; if(x==n+1) &#123;if(s==0) return 0;return INF;&#125; //递归的边界 return min(dfs(x+1,s),dfs(x+1,s^cha[x])+1); //枚举这一盏灯动不动&#125;inline void init() //读入函数，没什么好解释的把&#123; scanf("%d",&amp;n); memset(a,0,sizeof(a)); for(int i=1,t,x;i&lt;=n;i++) for(scanf("%d",&amp;t);t--;) scanf("%d",&amp;x),a[i][x]=1;&#125;inline void ready() //前面说的预处理部分&#123; memset(cha,0,sizeof(cha)); //cha代表change，表示动一下这个开关，会产生的影响的状态（已压缩 for(int i=1;i&lt;=n;i++) &#123; cha[i]^=ya(i-1); //它本身状态改变 for(int j=1;j&lt;=n;j++) //持续的第一轮 if(go(i,j)) &#123; cha[i]^=ya(j-1); for(int k=1;k&lt;=n;k++) if(go(j,k)) cha[i]^=ya(k-1); //它持续的第二轮 &#125; &#125; ans=dfs(1,ya(n)-1); //找到答案&#125;int main()&#123; return init(),ready(),ans&lt;=INF?printf("%d\n",ans):puts("Change an alarm clock，please!"),0; //一行的主程序完美地结束&#125;]]></content>
      <tags>
        <tag>动态规划</tag>
        <tag>状态压缩</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[P4912帕秋莉的魔法（题解）]]></title>
    <url>%2F2019%2F10%2F15%2FP4912%2F</url>
    <content type="text"><![CDATA[P4912帕秋莉的魔法（题解）Link.点我 PS.楼上的题解解释较少，希望这篇题解能帮助到你 Problem.有$\texttt{n}$个物品，每个物品有一个重量和一个价值，只能从前往后取物品。取了前面的物品之后会对下一个物品有一定的影响，使后一个物品的价值加上一个值。现在，你需要取重量和恰好为$\texttt{n}$的一些物品，使它们的价值和最大。 Solution.首先，每一个物品有两个属性，第一时间想到的应该是背包。所以根据背包常用套路，设$\texttt{dp[x][y]}$表示前$\texttt{x}$个物品中取出重量恰为$\texttt{y}$的最大价值和。所以$\texttt{dp[x][y+a[x]]=max(dp[k][y]+b[x]+w[k][x])}$。 Attention.这道题如果这样写的话不会得到全分，具体得分未亲测。因为这题中$\texttt{w}$可能为负数，如果单纯这样写会$\texttt{RE}$或$\texttt{WA}$。所以我们可以给第二位加一个偏移量，相当于程序中的$\texttt{dp[i][j]}$表示我们的$\texttt{dp[i][j-2500]}$。这样就能得全分了QwQ Coding.压行码风勿喷QwQ1234567891011121314#include&lt;bits/stdc++.h&gt;using namespace std;const int N=55,V=2500; //V：注意点重的偏移量int n,m,ans,a[N],b[N],w[N][N],dp[N][(V&lt;&lt;1)+5]; //此处解释略int main()&#123; scanf("%d%d",&amp;n,&amp;m); //读入 for(int i=1;i&lt;=n;i++) scanf("%d%d",a+i,b+i); for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=n;j++) scanf("%d",&amp;w[i][j]); memset(dp,~0x3f,sizeof(dp)),dp[0][V]=0; //初始化为最小值，方便以后处理 for(int i=0;i&lt;=n;i++) for(int j=i+1;j&lt;=n;j++) for(int k=(V&lt;&lt;1);k&gt;=0;k--) if(dp[i][k]!=dp[0][0]) dp[j][k+a[j]]=max(dp[j][k+a[j]],dp[i][k]+b[j]+w[i][j]); //最关键的一行语句，动态规划转移 ans=dp[0][0];for(int i=1;i&lt;=n;i++) ans=max(ans,dp[i][m+V]); //从所有恰好为m条语句中找出答案 return (ans==dp[0][0]?puts("-1"):printf("%d\n",ans)),0; //完美地一行输出&#125; 拒绝抄袭代码，营造良好洛谷]]></content>
      <tags>
        <tag>动态规划</tag>
        <tag>背包</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[P4703]]></title>
    <url>%2F2019%2F10%2F15%2FP4703%2F</url>
    <content type="text"><![CDATA[P4703偷上网（题解）Link.点我 PS.随机大法好用我做这道题，刚开始忘了可能有无解情况，$\texttt{T}$了$\texttt{4}$个点，说明无解的就四个点然后，又过了一段时间，终于把代码构对了后，发现随机种子也很重要。刚开始，我用$\texttt{time(0)}$来当随机种子，$\texttt{Wa}$了一个点。后来用其他的一些随机种子，结果都$\texttt{Wa}$了那一个点。一气之下，我翻了一下题解，抄了楼上的$\texttt{19260817}$作为随机种字，莫名其妙就对了。我感到特别玄学 Problem.就是给你$\texttt{n}$个圆，然后让你找出一个点，使它没被任何圆覆盖。输出这个点的坐标，没有则输出$\texttt{GG}$。 Solution.没什么好分析的直接暴力随机这个点的坐标，然后判断这个点是否在圆内。那么如何判断这个点是否在圆内呢？ 不会的点我具体详情请看代码。 Coding.123456789101112131415161718192021222324252627282930#include&lt;bits/stdc++.h&gt;using namespace std;const int N=15;struct point&#123;double x,y;&#125;a[N]; //点的结构体int n,l,m=1e7; //m表示随机次数inline point Rand() //生成平面上的随机一个点&#123; double x=rand(),y=rand(); while(x&gt;l) x/=10; while(y&gt;l) y/=10; return (point)&#123;x,y&#125;;&#125;inline double sqr(double x) &#123;return x*x;&#125; //平方函数inline char check(point b) //判断这个点是否在一个圆里面&#123; for(int i=1;i&lt;=n;i++) if(sqr(b.x-a[i].x)+sqr(b.y-a[i].y)&lt;sqr(double(l)/n)) return 1; printf("%.3lf %.3lf\n",b.x,b.y); return 0;&#125;int main()&#123; srand(19260817); //玄学的随机种字 scanf("%d%d",&amp;n,&amp;l); for(int i=1;i&lt;=n;i++) scanf("%lf%lf",&amp;a[i].x,&amp;a[i].y); while(check(Rand())&amp;&amp;m--); //不断随机点，判断 if(m==-1) puts("GG"); //判断不可行解 return 0;&#125;]]></content>
      <tags>
        <tag>计算几何</tag>
        <tag>随机化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[P1762偶数（题解）]]></title>
    <url>%2F2019%2F10%2F15%2FP1762%2F</url>
    <content type="text"><![CDATA[P1762偶数（题解）Link.点我 PS.此题关于杨辉三角，所以应该是数论。但是像我这种菜鸡，只能暴力打表出奇迹了。然后突然发现，好像自己打出了最短的题解。 Solution.首先，对于$\texttt{n}$比较小的数据可以打出一个表。打表辅助程序如下，相当于$\texttt{O(n}^\texttt{2}\texttt{)}$暴力解决1234567891011121314151617181920#include&lt;bits/stdc++.h&gt;#define lowbit(x) ((x)&amp;(-(x)))using namespace std;const int N=15;int a[2][10005],ans[10005],tr[10005];int main()&#123; memset(a,0,sizeof(a)),tr[0]=tr[1]=0; for(int i=0,tot=0;i&lt;=N;i++,tot=0) &#123; a[i&amp;1][0]=1; for(int j=1;j&lt;=i;j++) a[i&amp;1][j]=a[1-(i&amp;1)][j]+a[1-(i&amp;1)][j-1]; for(int j=0;j&lt;=i;j++) a[i&amp;1][j]&amp;=1; for(int j=0;j&lt;=i;j++) tot+=1-(a[i&amp;1][j]&amp;1); tr[i]=tr[i/2]+lowbit(i)/2,ans[i]=tot; for(int j=0;j&lt;=i;j++) printf("%c%c",a[i&amp;1][j]?'*':'.',j==i?'\n':' ');// printf("%d:%d\n",i+1,ans[i]); &#125; return 0;&#125; 打出来的表如下12345678910111213141516** ** . ** * * ** . . . ** * . . * ** . * . * . ** * * * * * * ** . . . . . . . ** * . . . . . . * ** . * . . . . . * . ** * * * . . . . * * * ** . . . * . . . * . . . ** * . . * * . . * * . . * ** . * . * . * . * . * . * . ** * * * * * * * * * * * * * * * 然后，发现它是一个分形图形，于是我们考虑用递归求解。设我们当前要处理的三角形边长为$\texttt{n}$，答案为$\texttt{f(n)}$，那么 \texttt{f(n)}=\left\{\begin{aligned}\texttt{3}^\texttt{k}\qquad\qquad\quad\qquad\texttt{(n=2}^\texttt{k}\texttt{且k}\in\mathbb{N}\texttt{)}\\\texttt{f(2}^\texttt{k}\texttt{)+f(n-2}^\texttt{k}\texttt{)}\quad\texttt{(2}^\texttt{k}\texttt{]]></content>
      <tags>
        <tag>数论</tag>
        <tag>杨辉三角</tag>
        <tag>打表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[P2250二面体群（题解）]]></title>
    <url>%2F2019%2F10%2F15%2FP2250%2F</url>
    <content type="text"><![CDATA[P2250二面体群（题解）Link.点我 PS.我不知道这道题为什么会是灰的，通过数还这么少。作为第三个$\texttt{A}$了这道题的人，来发一篇题解。这道题读入调了我半天呢。 problem.首先，在一个平面直角坐标系中，有一个单位园，它上面均匀分布了$\texttt{n}$个点。然后有两种操作，可以顺时针旋转$\frac{\texttt{2}\pi}{k}$弧度，也可以把它按照$\texttt{x}$轴对称。求一堆操作的最短等价操作是什么。 Solution.Part 1.首先，操作二上下轴对称是对点的相对分布是五影响的。所以，操作二与操作一是相对独立的，操作二只与操作一的旋转方向有关。所以可以记录下来操作二的操作次数，然后在执行操作一的时候加入操作二的次数，记录下逆时针旋转了几个单位。然后就记录下来了读入。 Part 2.从第一部分可以知道操作的总体显现情况，具体的说，就是$\texttt{t=}$有没有翻转，$\texttt{x=}$逆时针旋转了几个单位。然后可以从$\texttt{t}$与$\texttt{x}$中推出答案，具体看代码。 可能有一点玄乎，那么上代码吧 Coding.123456789101112131415161718192021222324252627282930#include&lt;bits/stdc++.h&gt;using namespace std;int n,x,t=1,a=0;char c;inline void init() //第一部分 读入&#123; scanf("%d\n",&amp;n),c=getchar(); //读入第一行的数以及第二行的第一个字符。 while(1) //一直循环 &#123; while(c!='\n'&amp;&amp;c!=EOF&amp;&amp;c!='r'&amp;&amp;c!='m') c=getchar(); //这里有锅，见下一行 if(c=='\n'||c==EOF) break; //数据有锅，如果这里没有EOF的话亲测最后一个点会TLE。 scanf("%d",&amp;x); //读入操作数据 if(c=='r') (a+=t*x%n)%=n; //旋转操作直接模拟，要加上翻转操作中的顺逆时针，这条语句相当于a=(a+t*x%n)%n; if(c=='m') t=(x&amp;1)?-t:t; //翻转操作，记录下来有多少次翻转（奇数是-1，偶数是1） c=getchar(); //继续读 &#125; (a+=n)%=n; //防止a&lt;0&#125;inline void out()&#123; if(n+1-a-t&lt;a) printf("m1 r%d ",n-a),t=-t; //这个特判也卡了我半天QwQ，特判语句我试了半天// 1-t表示先翻转（可能之后的翻转不需要，或者之后多出来一次翻转），n-a表示翻转之后顺时针旋转。然后t要取反 else if(a) printf("r%d ",a); //如果a=0，就不需要输出了。 if(t==-1) printf("m1 "); //如果还有一次 puts(""); //个人强迫症&#125;int main()&#123; return init(),out(),0; //完美主程序结束&#125;]]></content>
      <tags>
        <tag>计算几何</tag>
        <tag>标记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[P4862猜数（题解）]]></title>
    <url>%2F2019%2F10%2F15%2FP4862%2F</url>
    <content type="text"><![CDATA[P4862猜数（题解）Link.点我 PS.讲一下个人对于这道题的心路历程吧。这道题就是一道硬生生把两道题合并成一道的经典例子。首先，看到这道题时，没有看到数据范围，然后这道题就被放置了很久。后来才发现最后几个$\texttt{n}$特别大的测试数据点的$\texttt{a=2}$与$\texttt{b=1}$。然后，即使$\texttt{a=2}$且$\texttt{b=1}$，我仍然不会做 我就是菜于是，我想骗一下$\texttt{70}$分的做法，然后想到了递推。然后，过了很久，又想到去把$\texttt{a=2}$与$\texttt{b=1}$去带入递推式，打表找一下规律。突然发现答案有关菲波那切数列，就做出来了。借此我想告诉大家，我也不知道为什么答案是这样的 Solution.70 point首先，引进一个感性理解定理：在m在S中并且S的元素数目不变的前提下，Iris选择的数m以及S的元素对答案是没有影响的。所以，我们可以设$\texttt{f(n)}$表示在$\texttt{[1,n]}$，问出答案的最优策略花费的金额。 \texttt{f(x)}=\left\{\begin{aligned}\texttt{0}\quad\texttt{(x==1)}\\\texttt{min\{max(f(i)+a,f(x-i)+b)\}}\quad\texttt{(x!=1)}\end{aligned}\right.然鹅这个递推式的复杂度是$\texttt{O(n}^\texttt{2}\texttt{)}$，只能骗来$\texttt{70}$分。 30 point但是，我们把$\texttt{a=2}$和$\texttt{b=1}$带入上式，然后打表找一下规律。我打出了这个表12345678910111213141 ans=02 ans=23 ans=34 ans=45 ans=46 ans=57 ans=58 ans=59 ans=610 ans=611 ans=612 ans=613 ans=614 ans=7 经过整理后是这样的1234567891-10 12-22 23-33 34-54 56-85 89-13 6 13...... 我们发现，最右端是斐波那契数列，然后再打一通表，就发现$\texttt{f(100)&gt;10}^\texttt{18}$。所以复杂度是$\texttt{O(max(100,t))}$，能过。至此，这道题终于做完了。 Coding.有SB特判，有注释版本12345678910111213141516171819202122232425262728293031#include&lt;bits/stdc++.h&gt; //我爱用万能头using namespace std;typedef long long ll;const int N=2000,M=100; //N表示前7个点的范围，M表示后3个点的范围int a,b,t;ll n,f[N+5];inline void work1() //处理前7个点。&#123; memset(f,0x3f,sizeof(f)),f[1]=0; //要求最大值的最小值，初始值INF for(int i=1;i&lt;=N;i++) for(int j=1;j&lt;i;j++) f[i]=min(f[i],max(f[j]+a,f[i-j]+b)); //由上面的递推式得到 while(t--) scanf("%lld",&amp;n),printf("%lld\n",f[n]); //回答询问&#125;inline void work2() //处理后3个点。&#123; f[0]=1,f[1]=1; for(int i=2;i&lt;=M;i++) f[i]=f[i-1]+f[i-2]; //预处理斐波那契数列 while(t--) &#123; scanf("%lld",&amp;n); if(n==1) &#123;puts("0");continue;&#125; //SB特判 for(int i=1;i&lt;=M;i++) if(n&lt;=f[i]) &#123;printf("%d\n",i);break;&#125; //打表找出的规律 &#125;&#125;int main()&#123; scanf("%d%d%d",&amp;a,&amp;b,&amp;t); if(a!=2||b!=1) work1(); //处理前7个点 else work2(); //处理后3个点 return 0;&#125; 不用SB特判，无注释版本：123456789101112131415161718192021222324252627282930#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int N=2000,M=100;int a,b,t;ll n,f[N+5];inline void work1()&#123; memset(f,0x3f,sizeof(f)),f[1]=0; for(int i=1;i&lt;=N;i++) for(int j=1;j&lt;i;j++) f[i]=min(f[i],max(f[j]+a,f[i-j]+b)); while(t--) scanf("%lld",&amp;n),printf("%lld\n",f[n]);&#125;inline void work2()&#123; f[0]=1,f[1]=1; for(int i=2;i&lt;=M;i++) f[i]=f[i-1]+f[i-2]; while(t--) &#123; scanf("%lld",&amp;n); for(int i=0;i&lt;=M;i++) if(n&lt;=f[i]) &#123;printf("%d\n",i);break;&#125; &#125;&#125;int main()&#123; scanf("%d%d%d",&amp;a,&amp;b,&amp;t); if(a!=2||b!=1) work1(); else work2(); return 0;&#125;]]></content>
      <tags>
        <tag>打表</tag>
        <tag>斐波那契数列</tag>
        <tag>递推</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【原创】Bulfly]]></title>
    <url>%2F2019%2F10%2F10%2Fgame2%2F</url>
    <content type="text"><![CDATA[这里有一个菜鸡的游戏版权声明：作者系小跳蛙这个游戏还在调试阶段，如有bug欢迎私信小跳蛙点击显/隐代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561#include&lt;bits/stdc++.h&gt;#include&lt;windows.h&gt;#define KEY_DOWN(VK_NONAME) ((GetAsyncKeyState(VK_NONAME)&amp;0x8000)?1:0)using namespace std;int N=15,Numk=50,Numl=5,Numd=100,Nan=40,Hp=10,Bebc=15,Bebh=16,Bebb=10,squ=3;struct node&#123; int x,y,vf,bv; inline void init() &#123;x=rand()%N+1,y=rand()%N+1,bv=rand()%3+1;&#125; inline void move() &#123;x++;if(x&gt;N) init(),x=1;&#125;&#125;k[10005],l[10005],d[10005];int x,y,hp,score,mp[25][25],udf,numc,numh,numb,bulc,bulh,bulb,lanf;inline void add(int &amp;x,int y) &#123;x+=y,x=max(x,1),x=min(x,N);&#125;void color(int a) &#123;SetConsoleTextAttribute(GetStdHandle(STD_OUTPUT_HANDLE),a);&#125;inline int read()&#123; int r=0;char c=getchar(); while(c&gt;'9'||c&lt;'0') c=getchar(); while(c&gt;='0'&amp;&amp;c&lt;='9') (r*=10)+=c-'0',c=getchar(); return r;&#125;inline void print(int x,int y,string s)&#123; HANDLE hOut;COORD pos; hOut=GetStdHandle(STD_OUTPUT_HANDLE),pos.X=y,pos.Y=x; SetConsoleCursorPosition(hOut,pos),cout&lt;&lt;s;&#125;inline char check_press(int x)&#123; Sleep(100); for(int i=1;i&lt;=10;i++) &#123;if(KEY_DOWN(x)) return 1;Sleep(10);&#125; return 0;&#125;inline void set_windows(int x1,int y1,int x2,int y2)&#123; HANDLE hOut=GetStdHandle(STD_OUTPUT_HANDLE);SMALL_RECT rc; rc.Left=x1,rc.Top=y1,rc.Right=x2,rc.Bottom=y2; SetConsoleWindowInfo(hOut, TRUE, &amp;rc);&#125;inline void disap_mouse()&#123; ShowCursor(false); HANDLE hOut=GetStdHandle(STD_OUTPUT_HANDLE); CONSOLE_CURSOR_INFO cci; GetConsoleCursorInfo(hOut,&amp;cci); cci.bVisible=false; SetConsoleCursorInfo(hOut,&amp;cci);&#125;inline char check_die()&#123; for(int i=1;i&lt;=Numk;i++) if(k[i].x==x&amp;&amp;k[i].y==y) return k[i].init(),k[i].x=1,0; return 1;&#125;inline char check_luck()&#123; for(int i=1;i&lt;=Numl;i++) if(l[i].x==x&amp;&amp;l[i].y==y) &#123; l[i].init(),l[i].x=1; numc+=(rand()%10+5)*bulc; numh+=(rand()%5+5)*bulh; numb+=(rand()%5+5)*bulb; return 0; &#125; return 1;&#125;inline char check_dowm()&#123; for(int i=1;i&lt;=Numd;i++) if(d[i].x==x&amp;&amp;d[i].y==y) &#123; d[i].init(),d[i].x=1; numc+=(rand()%10+5)*bulc; numh+=(rand()%5+5)*bulh; numb+=(rand()%5+5)*bulb; return 0; &#125; return 1;&#125;inline void move_thi()&#123; for(int i=1;i&lt;=Numk;i++) if(k[i].vf==0) k[i].move(); for(int i=1;i&lt;=Numl;i++) if(l[i].vf==0) l[i].move(); for(int i=1;i&lt;=Numd;i++) if(d[i].vf==0) d[i].move();&#125;inline char move_peo()&#123; char c=0; if(KEY_DOWN(87)&amp;&amp;!udf) add(x,-1),c=1; if(KEY_DOWN(38)&amp;&amp;!udf) add(x,-1),c=1; if(KEY_DOWN(104)&amp;&amp;!udf) add(x,-1),c=1; if(KEY_DOWN(87)||KEY_DOWN(38)||KEY_DOWN(104)) color(112),print(11,N+5,"↑"),color(7);else print(11,N+5,"↑"); if(KEY_DOWN(83)&amp;&amp;!udf) add(x,1),c=1; if(KEY_DOWN(40)&amp;&amp;!udf) add(x,1),c=1; if(KEY_DOWN(101)&amp;&amp;!udf) add(x,1),c=1; if(KEY_DOWN(83)||KEY_DOWN(40)||KEY_DOWN(101)) color(112),print(15,N+5,"↓"),color(7);else print(15,N+5,"↓"); if(KEY_DOWN(65)) add(y,-1),c=1; if(KEY_DOWN(37)) add(y,-1),c=1; if(KEY_DOWN(100)) add(y,-1),c=1; if(KEY_DOWN(65)||KEY_DOWN(37)||KEY_DOWN(100)) color(112),print(13,N+3,"←"),color(7);else print(13,N+3,"←"); if(KEY_DOWN(68)) add(y,1),c=1; if(KEY_DOWN(39)) add(y,1),c=1; if(KEY_DOWN(102)) add(y,1),c=1; if(KEY_DOWN(68)||KEY_DOWN(39)||KEY_DOWN(102)) color(112),print(13,N+7,"→"),color(7);else print(13,N+7,"→"); return c;&#125;inline void die()&#123; system("cls"),print(0,0,""); if(lanf==1) &#123; puts("YOU DIED!!!\n"),Sleep(1000); printf("YOU SCORE IS:%d\n\n",score),Sleep(1000); &#125; if(lanf==0) &#123; puts("你终于知道 死 这个字怎么写了！！！\n"),Sleep(1000); printf("你的分数是：%d\n\n",score),Sleep(1000); &#125; if(lanf==1) puts("TRY AGAIN?\n"); if(lanf==0) puts("再来一局？\n");&#125;inline void init()&#123; system("cls"),srand(time(0)),printf(" "); for(int i=1;i&lt;=N;i++) printf("~"); puts(""); for(int i=1;i&lt;=N;i++) &#123; printf("|"); for(int i=1;i&lt;=N;i++) printf(" "); puts("|"); &#125; printf(" "); for(int i=1;i&lt;=N;i++) printf("~"); puts(""),x=N,y=N/2,hp=Hp,score=0,numc=Bebc*bulc,numh=Bebh*bulh,numb=Bebb*bulb; for(int i=1;i&lt;=Numk;i++) k[i].init(),k[i].y=N+1,k[i].vf=k[i].bv-1; for(int i=1;i&lt;=Numl;i++) l[i].init(),l[i].y=N+1,l[i].vf=l[i].bv-1; for(int i=1;i&lt;=Numd;i++) d[i].init(),d[i].y=N+1,d[i].vf=d[i].bv-1; print(1,N+2," "),printf("The bloods you still have"); print(3,N+2," "),printf("The score you have now is"); print(5,N+2," "),printf("The normal bullet you have is"); print(7,N+2," "),printf("The high bullet you have is"); print(9,N+2," "),printf("The big bullet you have is"); for(int i=1;i&lt;=Hp/30;i++) &#123; print(16+i,N+2,"-"); for(int i=2;i&lt;=30;i++) printf("-"); &#125; print(17+Hp/30,N+2,"-"); for(int i=2;i&lt;=Hp%30;i++) printf("-"); print(x,y,"*");&#125;inline void Begin()&#123; disap_mouse(),set_windows(10,10,89,55),system("cls"); printf("\n"),printf("WELCOME TO THE GAME:\n"),color(14); printf( "\n" "BBBBee U U L FFFFFF L Y Y \n" "B B U U L F L Y Y \n" "B B U U L F L Y Y \n" "BBBBBB U U L FFFFFF L YY \n" "B B U U L F L YY \n" "B B U U L F L YY \n" "BBBB^^ UUUU LLLLLL F LLLLLL YY \n" "\n" ); color(12),printf("烤蛙出品，侵权必究！QWQ\n\nBelieve_R_ 赞助开发\n\n"); color(7),Sleep(500),puts("PLEASE PRESS 'Enter' TO CONTINUE"); while(1) &#123;if(KEY_DOWN(13)) break;&#125; Sleep(200),system("cls"),puts("Your Language?/你的语言？"),lanf=0; while(1) &#123; print(2,0," "); if(lanf==1) puts(" 中文 ");else color(112),puts(" 中文 "),color(7); print(3,0," "); if(lanf==0) puts(" English ");else color(112),puts(" English"),color(7); if(KEY_DOWN(13)||KEY_DOWN(108)) break; if(KEY_DOWN(87)||KEY_DOWN(83)||KEY_DOWN(38)||KEY_DOWN(40)||KEY_DOWN(104)||KEY_DOWN(101)) lanf=1-lanf; Sleep(100); &#125; int t=0; Sleep(200),system("cls"); if(lanf==1) puts("Do you know the rule of the game?"); if(lanf==0) puts("你知道此游戏的规则吗\n"); while(1) &#123; if(lanf==1) &#123; print(2,0," "); if(t==1) puts(" Yes ");else color(112),puts(" Yes "),color(7); print(3,0," "); if(t==0) puts(" No ");else color(112),puts(" No "),color(7); &#125; if(lanf==0) &#123; print(2,0," "); if(t==1) puts(" 是 ");else color(112),puts(" 是 "),color(7); print(3,0," "); if(t==0) puts(" 否 ");else color(112),puts(" 否 "),color(7); &#125; if(KEY_DOWN(13)||KEY_DOWN(108)) break; if(KEY_DOWN(87)||KEY_DOWN(83)||KEY_DOWN(38)||KEY_DOWN(40)||KEY_DOWN(104)||KEY_DOWN(101)) t=1-t; Sleep(100); &#125; if(t==1) &#123; Sleep(200),system("cls"); if(lanf==1) &#123; puts("Before playing this game please read these carefully:\n"),Sleep(500); puts("\n1. You'll be asked to input 7 game parameters before the game starts.\n"),Sleep(500); puts("\n2. The symbol '!' is the Upgrade Roadblock. If you didn't shut it off before it get to the botton, your bloods will -1!\n"),Sleep(500); puts("\n3. The symbol '&amp;' is the obstacle which means you cannot let '*' touch the '#'.\n"),Sleep(500); puts("\n4. The symbol '+' is the midic which means you can recover by touching the '!'.\n"),Sleep(500); puts("\n5. At first, you will have some bloods. You must go further before you died!\n"),Sleep(500); puts("\n6. If you press 'Q', the bullets will be fired. But the bullets was limited, it only can be increased by touching '+'\n"),Sleep(500); puts("\n7. If you press 'Space', the system will give you a sighting telescope. But it can't earse the Roadblock\n"),Sleep(500); puts("\n\nHappy Games...... QwQ\n"),Sleep(500); puts("PLEASE PRESS 'Enter' TO CONTINUE"); &#125; if(lanf==0) &#123; puts("在玩之前，请认真阅读以下提示：\n"),Sleep(500); puts("\n1. 你将输入7个游戏参数。\n"),Sleep(500); puts("\n2. 符号'!'是恐怖障碍物。如果你没有在它到达底部之前射掉它，你将会扣一滴血！\n"),Sleep(500); puts("\n3. 符号'&amp;'是障碍物，一旦你自己('*')碰到障碍物，生命值将会掉1个单位！\n"),Sleep(500); puts("\n4. 符号'+'可以给你补血，每次你自己('*')碰到'!'会恢复1个单位！\n"),Sleep(500); puts("\n5. 一开始你会有n个单位的生命，你必须在生命值耗完之前获得最高的分数！\n"),Sleep(500); puts("\n6. 如果你按下'Q'，将会发射子弹。但是子弹的数量是有限的，你有你碰到了'+'才会回血！\n"),Sleep(500); puts("\n7. 如果你按下'空格'，将会调出瞄准镜。但是瞄准镜并不能清除障碍物！\n"),Sleep(500); puts("\n\nHappy Games...... QwQ\n"),Sleep(500); puts("请按回车键以继续！"); &#125; &#125; while(1) &#123;if(KEY_DOWN(13)) break;&#125; system("cls");&#125;inline void choose()&#123; int t=5; Sleep(200); if(lanf==1) puts("Please choose the Difficulty: \n"); if(lanf==0) puts("请选择游戏难度：\n"); while(1) &#123; if(lanf==1) &#123; print(2,0," "); if(t!=5) puts(" Quick: No bullets ");else color(112),puts(" Quick: No bullets "),color(7); print(3,0," "); if(t!=4) puts(" Peaceful: Please play within 'int'! ");else color(112),puts(" Peaceful: Please play within 'int'! "),color(7); print(4,0," "); if(t!=3) puts(" Easy: Suitable for the Freshmen ");else color(112),puts(" Easy: Suitable for the Freshmen! "),color(7); print(5,0," "); if(t!=2) puts(" Middle: Time to race! ");else color(112),puts(" Middle: Time to race! "),color(7); print(6,0," "); if(t!=1) puts(" Hard: Impossible to get 2500! ");else color(112),puts(" Hard: Impossible to get 2500! "),color(7); print(7,0," "); if(t!=0) puts(" User-Defined ");else color(112),puts(" User-Defined "),color(7); &#125; if(lanf==0) &#123; print(2,0," "); if(t!=5) puts(" 手速 [没有子弹！] ");else color(112),puts(" 手速 [没有子弹！] "),color(7); print(3,0," "); if(t!=4) puts(" 和平 [不要把int玩爆呀！] ");else color(112),puts(" 和平 [不要把int玩爆呀！] "),color(7); print(4,0," "); if(t!=3) puts(" 简单 [新手建议！] ");else color(112),puts(" 简单 [新手建议！] "),color(7); print(5,0," "); if(t!=2) puts(" 普通 [是时候比速度了！] ");else color(112),puts(" 普通 [是时候比速度了！] "),color(7); print(6,0," "); if(t!=1) puts(" 困难 [2500? 不可能的！] ");else color(112),puts(" 困难 [2500? 不可能的！] "),color(7); print(7,0," "); if(t!=0) puts(" 用户自定义 ");else color(112),puts(" 用户自定义 "),color(7); &#125; if(KEY_DOWN(13)||KEY_DOWN(108)) break; if(KEY_DOWN(38)||KEY_DOWN(87)||KEY_DOWN(104)) t=(t+1)%6; if(KEY_DOWN(40)||KEY_DOWN(83)||KEY_DOWN(98)) t=(t+5)%6; Sleep(100); &#125; Nan=40; if(t==5) &#123;N=30,Numk=75,Numl=2,Numd=0,Hp=1,Bebc=Bebh=Bebb=0,bulc=bulh=bulb=0,squ=14;return;&#125; if(t==4) &#123;N=30,Numk=15,Numl=20,Numd=1,Hp=20,Bebc=500,Bebh=100,Bebb=100,bulc=bulh=bulb=1,squ=10;return;&#125; if(t==3) &#123;N=30,Numk=25,Numl=10,Numd=1,Hp=15,Bebc=100,Bebh=20,Bebb=20,bulc=bulh=bulb=1,squ=7;return;&#125; if(t==2) &#123;N=30,Numk=40,Numl=8,Numd=1,Hp=15,Bebc=20,Bebh=4,Bebb=2,bulc=bulh=bulb=1,squ=5;return;&#125; if(t==1) &#123;N=30,Numk=40,Numl=5,Numd=2,Hp=20,Bebc=10,Bebh=Bebb=0,bulc=bulh=bulb=1,squ=3;return;&#125; system("cls"),t=0,Sleep(100); if(lanf==1) puts("Do you want to be able to shoot the bullets?"); if(lanf==0) puts("请选择你能否发射狙击枪子弹！"); while(1) &#123; if(lanf==1) &#123; print(2,0," "); if(t==1) puts(" Yes ");else color(112),puts(" Yes "),color(7); print(3,0," "); if(t==0) puts(" No ");else color(112),puts(" No "),color(7); &#125; if(lanf==0) &#123; print(2,0," "); if(t==1) puts(" 是 ");else color(112),puts(" 是 "),color(7); print(3,0," "); if(t==0) puts(" 否 ");else color(112),puts(" 否 "),color(7); &#125; if(KEY_DOWN(13)||KEY_DOWN(108)) break; if(KEY_DOWN(87)||KEY_DOWN(83)||KEY_DOWN(38)||KEY_DOWN(40)||KEY_DOWN(104)||KEY_DOWN(101)) t=1-t; Sleep(100); &#125; bulc=1-t,t=0,system("cls"),Sleep(100); if(lanf==1) puts("Do you want to be able to shoot the bullets?"); if(lanf==0) puts("请选择你能否发射高射炮子弹！"); while(1) &#123; if(lanf==1) &#123; print(2,0," "); if(t==1) puts(" Yes ");else color(112),puts(" Yes "),color(7); print(3,0," "); if(t==0) puts(" No ");else color(112),puts(" No "),color(7); &#125; if(lanf==0) &#123; print(2,0," "); if(t==1) puts(" 是 ");else color(112),puts(" 是 "),color(7); print(3,0," "); if(t==0) puts(" 否 ");else color(112),puts(" 否 "),color(7); &#125; if(KEY_DOWN(13)||KEY_DOWN(108)) break; if(KEY_DOWN(87)||KEY_DOWN(83)||KEY_DOWN(38)||KEY_DOWN(40)||KEY_DOWN(104)||KEY_DOWN(101)) t=1-t; Sleep(100); &#125; bulh=1-t,t=0,system("cls"),Sleep(100); if(lanf==1) puts("Do you want to be able to shoot the bullets?"); if(lanf==0) puts("请选择你能否发射大炮子弹！"); while(1) &#123; if(lanf==1) &#123; print(2,0," "); if(t==1) puts(" Yes ");else color(112),puts(" Yes "),color(7); print(3,0," "); if(t==0) puts(" No ");else color(112),puts(" No "),color(7); &#125; if(lanf==0) &#123; print(2,0," "); if(t==1) puts(" 是 ");else color(112),puts(" 是 "),color(7); print(3,0," "); if(t==0) puts(" 否 ");else color(112),puts(" 否 "),color(7); &#125; if(KEY_DOWN(13)||KEY_DOWN(108)) break; if(KEY_DOWN(87)||KEY_DOWN(83)||KEY_DOWN(38)||KEY_DOWN(40)||KEY_DOWN(104)||KEY_DOWN(101)) t=1-t; Sleep(100); &#125; bulb=1-t,t=0,system("cls"),Sleep(100); if(lanf==1) puts("Please choose your pattern\nIf you choose Pattern 1, you can go up and down, while Pattern 2 can't!\n"); if(lanf==0) puts("请选择你的模式：\n如果你选择了模式1，你可以上下左右移动；而模式2只能左右移动！\n"); while(1) &#123; if(lanf==1) &#123; print(3,0," "); if(t==1) puts(" Pattern 1:←↑↓→ ");else color(112),puts(" Pattern 1:←↑↓→ "),color(7); print(4,0," "); if(t==0) puts(" Pattern 2:←→ ");else color(112),puts(" Pattern 2:←→ "),color(7); &#125; if(lanf==0) &#123; print(3,0," "); if(t==1) puts(" 模式1:←↑↓→ ");else color(112),puts(" 模式1:←↑↓→ "),color(7); print(4,0," "); if(t==0) puts(" 模式2:←→ ");else color(112),puts(" 模式2:←→ "),color(7); &#125; if(KEY_DOWN(13)||KEY_DOWN(108)) break; if(KEY_DOWN(87)||KEY_DOWN(83)||KEY_DOWN(38)||KEY_DOWN(40)||KEY_DOWN(104)||KEY_DOWN(101)) t=1-t; Sleep(100); &#125; udf=t; system("cls"),t=-1; while(t&lt;3||t&gt;35) &#123; if(lanf==1) puts("Please Input an Integer: The Size of the Game(from 3 to 35):\n"); if(lanf==0) puts("请输入一个整数：游戏界面的大小（3 ~ 35）\n"); print(2,0," "),t=read(),N=t,system("cls"); &#125; system("cls"),t=-1; while(t&lt;1||90&lt;t) &#123; if(lanf==1) puts("Please Input an Integer: The Number of Bullets(from 1 to 90):\n"); if(lanf==0) puts("请输入一个整数：障碍物的数量（1 ~ 90）\n"); print(2,0," "),t=read(),Numk=t,system("cls"); &#125; system("cls"),t=-1; while(t&lt;1||90&lt;t) &#123; if(lanf==1) puts("Please Input an Integer: The Number of Backpack(from 1 to 90):\n"); if(lanf==0) puts("请输入一个整数：回血包的数量（1 ~ 90）\n"); print(2,0," "),t=read(),Numl=t,system("cls"); &#125; system("cls"),t=-1; while(t&lt;1||90&lt;t) &#123; if(lanf==1) puts("Please Input an Integer: The Number of Upgrade Bullets(from 1 to 90):\n"); if(lanf==0) puts("请输入一个整数：恐怖障碍物的数量（1 ~ 90）\n"); print(2,0," "),t=read(),Numd=t,system("cls"); &#125; system("cls"),t=-1; while(t&lt;1||t&gt;100) &#123; if(lanf==1) puts("Please Imput an Integer: The Total HP of You(from 1 to 100):\n"); if(lanf==0) puts("请输入一个整数：初始生命值（1 ~ 100）\n"); print(2,0," "),t=read(),Hp=t,system("cls"); &#125; system("cls"),t=-1; while(t&lt;1||t&gt;100) &#123; if(lanf==1) puts("Please Input an Integer: The Bullet You Have at First(from 1 to 100):\n"); if(lanf==0) puts("请输入一个整数：初始狙击枪子弹数（1 ~ 100）\n"); print(2,0," "),t=read(),Bebc=t,system("cls"); &#125; system("cls"),t=-1; while(t&lt;1||t&gt;100) &#123; if(lanf==1) puts("Please Input an Integer: The Bullet You Have at First(from 1 to 100):\n"); if(lanf==0) puts("请输入一个整数：初始高射炮子弹数（1 ~ 100）\n"); print(2,0," "),t=read(),Bebh=t,system("cls"); &#125; system("cls"),t=-1; while(t&lt;1||t&gt;100) &#123; if(lanf==1) puts("Please Input an Integer: The Bullet You Have at First(from 1 to 100):\n"); if(lanf==0) puts("请输入一个整数：初始大炮子弹数（1 ~ 100）\n"); print(2,0," "),t=read(),Bebb=t,system("cls"); &#125;&#125;inline void work()&#123; choose(),init(); int die=1,luck=1,dowm=1,t=1; while(1) &#123; for(int i=1;i&lt;=Numk;i++) (k[i].vf+=1)%=k[i].bv; for(int i=1;i&lt;=Numl;i++) (l[i].vf+=1)%=l[i].bv; for(int i=1;i&lt;=Numd;i++) (d[i].vf+=1)%=d[i].bv; for(int i=1;i&lt;=Numk;i++) if(k[i].y&lt;=N&amp;&amp;k[i].x&gt;0&amp;&amp;k[i].vf==0) print(k[i].x,k[i].y," "); for(int i=1;i&lt;=Numl;i++) if(l[i].y&lt;=N&amp;&amp;l[i].x&gt;0&amp;&amp;l[i].vf==0) print(l[i].x,l[i].y," "); for(int i=1;i&lt;=Numd;i++) if(d[i].y&lt;=N&amp;&amp;d[i].x&gt;0&amp;&amp;d[i].vf==0) print(d[i].x,d[i].y," ");t=0; if(!udf&amp;&amp;(KEY_DOWN(87)||KEY_DOWN(38)||KEY_DOWN(104))) t=1; if(!udf&amp;&amp;(KEY_DOWN(83)||KEY_DOWN(40)||KEY_DOWN(101))) t=1; if(KEY_DOWN(65)||KEY_DOWN(37)||KEY_DOWN(100)) t=1; if(KEY_DOWN(68)||KEY_DOWN(39)||KEY_DOWN(102)) t=1; if(t) print(x,y," ");move_thi(),t=move_peo();if(t) print(x,y,"*"); for(int i=1;i&lt;=Numk;i++) if(k[i].y&lt;=N&amp;&amp;k[i].x&gt;0&amp;&amp;k[i].vf==0) color(4),print(k[i].x,k[i].y,"&amp;"),color(7); for(int i=1;i&lt;=Numl;i++) if(l[i].y&lt;=N&amp;&amp;l[i].x&gt;0&amp;&amp;l[i].vf==0) color(2),print(l[i].x,l[i].y,"+"),color(7); for(int i=1;i&lt;=Numd;i++) if(d[i].y&lt;=N&amp;&amp;d[i].x&gt;0&amp;&amp;d[i].vf==0) color(14),print(d[i].x,d[i].y,"!"),color(7); die=check_die(),luck=check_luck(),dowm=check_dowm(); if(!luck) print(hp/30+17,N+2+hp%30,"-"),hp++,score+=20,(numc+=rand()%10+5)*=bulc,(numh+=rand()%5+5)*=bulh,(numb+=rand()%5)*=bulb; if(!die) print((hp-1)/30+17,N+2+(hp-1)%30," "),hp--,score+=10; if(!dowm) score+=50; if(!die||!luck||!dowm) print(x,y,"*"); if(hp&lt;=0) return; int xx=0,xw=1,yy=0,_90=0,_88=0,_67=0,_32=0; for(int i=1;i&lt;=Numk;i++) if(k[i].y==y&amp;&amp;xx&lt;k[i].x&amp;&amp;k[i].x&lt;x) xx=k[i].x,yy=k[i].y,xw=i; for(int i=1;i&lt;=Numl;i++) if(l[i].y==y&amp;&amp;xx&lt;l[i].x&amp;&amp;l[i].x&lt;x) xx=l[i].x,yy=l[i].y,xw=i+Numk; for(int i=1;i&lt;=Numd;i++) if(d[i].y==y&amp;&amp;xx&lt;d[i].x&amp;&amp;d[i].x&lt;x) xx=d[i].x,yy=d[i].y,xw=i+Numk+Numl; if(KEY_DOWN(32)) &#123;for(int i=x-1;i&gt;xx;i--) print(i,y,"|");_32=1,color(112),print(15,N+8," Space "),color(7);&#125;else print(15,N+8," Space "); if(KEY_DOWN(90)&amp;&amp;numc&gt;0) &#123; numc--,color(112),print(13,N+9," Z "),color(7),_90=1; if(xx!=0&amp;&amp;numc&gt;0) for(int i=x-1;i&gt;=xx;i--) print(i,y,"|"); &#125; else print(13,N+9," Z "); if(KEY_DOWN(88)&amp;&amp;numh&gt;0) &#123; numh--,color(112),print(13,N+12," X "),color(9),_88=1; if(xx!=0&amp;&amp;numc&gt;0) for(int i=x-1;i&gt;=1;i--) print(i,y,"|"); color(7); &#125; else print(13,N+12," X "); if(KEY_DOWN(67)&amp;&amp;numb&gt;0) &#123; numb--,color(112),print(13,N+15," C "),color(12),_67=1; if(xx!=0&amp;&amp;numc&gt;0) for(int i=x-1;i&gt;=xx;i--) print(i,y,"|"); color(7); &#125; else print(13,N+15," C "); for(int i=N+28;i&lt;=N+35;i++) print(1,i," "); for(int i=N+28;i&lt;=N+35;i++) print(3,i," "); for(int i=N+33;i&lt;=N+38;i++) print(5,i," "); for(int i=N+31;i&lt;=N+36;i++) print(7,i," "); for(int i=N+30;i&lt;=N+36;i++) print(9,i," "); print(1,N+29,":"),printf("%d",hp); print(3,N+29,":"),printf("%d",score); print(5,N+33,":"),printf("%d",numc); print(7,N+31,":"),printf("%d",numh); print(9,N+30,":"),printf("%d",numb); Sleep(Nan); if(_32==1) &#123;for(int i=x-1;i&gt;xx;i--) print(i,y," ");&#125; if(xx!=0&amp;&amp;_90) &#123; for(int i=x;i&gt;=xx;i--) print(i,y," "); if(xw&lt;=Numk) k[xw].init(),k[xw].x=0,score++; else if(xw&lt;=Numk+Numl) l[xw-Numk].init(),l[xw-Numk].x=0,score+=20; else d[xw-Numk-Numl].init(),d[xw-Numk-Numl].x=0,score++,(numc+=rand()%10+5)*=bulc,(numh+=rand()%5+5)*=bulh,(numb+=rand()%5)*=bulb; &#125; if(_88) &#123; for(int i=x;i&gt;=1;i--) print(i,y," "); for(int i=1;i&lt;=Numk;i++) if(k[i].y==y) k[i].init(),k[i].x=0,score++; for(int i=1;i&lt;=Numl;i++) if(l[i].y==y) l[i].init(),l[i].x=0,score+=20; for(int i=1;i&lt;=Numd;i++) if(d[i].y==y) d[i].init(),d[i].x=0,score++,(numc+=rand()%10+5)*=bulc,(numh+=rand()%5+5)*=bulh,(numb+=rand()%5)*=bulb; &#125; if(xx!=0&amp;&amp;_67) &#123; for(int i=x;i&gt;=1;i--) print(i,y," "); for(int i=1;i&lt;=Numk;i++) if(k[i].y&gt;=yy-squ&amp;&amp;k[i].y&lt;=yy+squ&amp;&amp;k[i].x&gt;=xx-squ&amp;&amp;k[i].x&lt;=xx+squ&amp;&amp;k[i].x&gt;=1&amp;&amp;k[i].y&lt;=N) print(k[i].x,k[i].y," "),k[i].init(),k[i].x=0,score++; for(int i=1;i&lt;=Numl;i++) if(l[i].y&gt;=yy-squ&amp;&amp;l[i].y&lt;=yy+squ&amp;&amp;l[i].x&gt;=xx-squ&amp;&amp;l[i].x&lt;=xx+squ&amp;&amp;l[i].x&gt;=1&amp;&amp;k[i].y&lt;=N) print(l[i].x,l[i].y," "),l[i].init(),l[i].x=0,score++; for(int i=1;i&lt;=Numd;i++) if(d[i].y&gt;=yy-squ&amp;&amp;d[i].y&lt;=yy+squ&amp;&amp;d[i].x&gt;=xx-squ&amp;&amp;d[i].x&lt;=xx+squ&amp;&amp;d[i].x&gt;=1&amp;&amp;k[i].y&lt;=N) print(d[i].x,d[i].y," "),d[i].init(),d[i].x=0,score++,(numc+=rand()%10+5)*=bulc,(numh+=rand()%5+5)*=bulh,(numb+=rand()%5)*=bulb; &#125; score++; &#125;&#125;int main()&#123; Begin(); while(1) &#123; work(),die();int t=0; while(1) &#123; if(lanf==1) &#123; print(5,0," "); if(t==1) puts(" Yes ");else color(112),puts(" Yes "),color(7); print(6,0," "); if(t==0) puts(" No ");else color(112),puts(" No "),color(7); &#125; if(lanf==0) &#123; print(5,0," "); if(t==1) puts(" 是 ");else color(112),puts(" 是 "),color(7); print(6,0," "); if(t==0) puts(" 否 ");else color(112),puts(" 否 "),color(7); &#125; if(KEY_DOWN(13)||KEY_DOWN(108)) break; if(KEY_DOWN(87)||KEY_DOWN(83)||KEY_DOWN(38)||KEY_DOWN(40)||KEY_DOWN(104)||KEY_DOWN(101)) t=1-t; Sleep(100); &#125; if(t==1) return 0; system("cls"); &#125;&#125;]]></content>
      <tags>
        <tag>娱乐</tag>
        <tag>c++小游戏</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【转载】原子战役]]></title>
    <url>%2F2019%2F10%2F10%2Fgame1%2F</url>
    <content type="text"><![CDATA[这里有神仙的游戏版权声明：作者系Little_Ming当然，这是经过小跳蛙魔改后的版本，增加了几个地图。点击显/隐代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697989910010110210310410510610710810911011111211311411511611711811912012112212312412512612712812913013113213313413513613713813914014114214314414514614714814915015115215315415515615715815916016116216316416516616716816917017117217317417517617717817918018118218318418518618718818919019119219319419519619719819920020120220320420520620720820921021121221321421521621721821922022122222322422522622722822923023123223323423523623723823924024124224324424524624724824925025125225325425525625725825926026126226326426526626726826927027127227327427527627727827928028128228328428528628728828929029129229329429529629729829930030130230330430530630730830931031131231331431531631731831932032132232332432532632732832933033133233333433533633733833934034134234334434534634734834935035135235335435535635735835936036136236336436536636736836937037137237337437537637737837938038138238338438538638738838939039139239339439539639739839940040140240340440540640740840941041141241341441541641741841942042142242342442542642742842943043143243343443543643743843944044144244344444544644744844945045145245345445545645745845946046146246346446546646746846947047147247347447547647747847948048148248348448548648748848949049149249349449549649749849950050150250350450550650750850951051151251351451551651751851952052152252352452552652752852953053153253353453553653753853954054154254354454554654754854955055155255355455555655755855956056156256356456556656756856957057157257357457557657757857958058158258358458558658758858959059159259359459559659759859960060160260360460560660760860961061161261361461561661761861962062162262362462562662762862963063163263363463563663763863964064164264364464564664764864965065165265365465565665765865966066166266366466566666766866967067167267367467567667767867968068168268368468568668768868969069169269369469569669769869970070170270370470570670770870971071171271371471571671771871972072172272372472572672772872973073173273373473573673773873974074174274374474574674774874975075175275375475575675775875976076176276376476576676776876977077177277377477577677777877978078178278378478578678778878979079179279379479579679779879980080180280380480580680780880981081181281381481581681781881982082182282382482582682782882983083183283383483583683783883984084184284384484584684784884985085185285385485585685785885986086186286386486586686786886987087187287387487587687787887988088188288388488588688788888989089189289389489589689789889990090190290390490590690790890991091191291391491591691791891992092192292392492592692792892993093193293393493593693793893994094194294394494594694794894995095195295395495595695795895996096196296396496596696796896997097197297397497597697797897998098198298398498598698798898999099199299399499599699799899910001001100210031004100510061007100810091010101110121013101410151016101710181019102010211022102310241025102610271028102910301031103210331034103510361037103810391040104110421043104410451046104710481049105010511052105310541055105610571058105910601061106210631064106510661067106810691070107110721073107410751076107710781079108010811082108310841085108610871088108910901091109210931094109510961097109810991100110111021103110411051106110711081109111011111112111311141115111611171118111911201121112211231124112511261127112811291130113111321133113411351136113711381139114011411142114311441145114611471148114911501151115211531154115511561157115811591160116111621163116411651166116711681169117011711172117311741175117611771178117911801181118211831184118511861187118811891190119111921193119411951196119711981199120012011202120312041205120612071208120912101211121212131214121512161217121812191220122112221223122412251226122712281229123012311232123312341235123612371238123912401241124212431244124512461247124812491250125112521253125412551256125712581259126012611262126312641265126612671268126912701271127212731274127512761277127812791280128112821283128412851286128712881289129012911292129312941295129612971298129913001301130213031304130513061307130813091310131113121313131413151316131713181319132013211322132313241325132613271328132913301331133213331334133513361337133813391340134113421343134413451346134713481349135013511352135313541355135613571358135913601361136213631364136513661367136813691370137113721373137413751376137713781379138013811382138313841385138613871388138913901391139213931394139513961397139813991400140114021403140414051406140714081409141014111412141314141415141614171418141914201421142214231424142514261427142814291430143114321433143414351436#include&lt;bits/stdc++.h&gt;using namespace std;const unsigned char ARROW=0XE0;const unsigned char LEFT=0X4B;const unsigned char RIGHT=0X4D;const unsigned char DOWN=0X50;const unsigned char UP=0X48; const unsigned char ESCAPE=033;const int MAP_SIZE=9; //地图大小const int SCREEN_SIZE=MAP_SIZE/2;const int PEOPLE_NUMBER=8; //总玩家数const int HUMAN_NUMBER=1; //人类玩家数#if falseint kbhit() &#123; return 0;&#125;int getch() &#123; return getchar();&#125;//void initKeyBoard() &#123;&#125; void closeKeyBoard() &#123;&#125; enum C;OLOR &#123;COLOR_BLACK=0,COLOR_DARK_BLUE=1,COLOR_DARK_GREEN=2,COLOR_DARK_BG=3,COLOR_DARK_RED=4,COLOR_DARK_PURPLE=5,COLOR_DARK_YELLOW=6,COLOR_DARK_WHITE=7,COLOR_GRAY=8,COLOR_BLUE=9,COLOR_GREEN=10,COLOR_BG=11,COLOR_RED=12,COLOR_PURPLE=13,COLOR_YELLOW=14,COLOR_WHITE=15&#125;;class Printer &#123; public: string s; COLOR f1,f2; bool bu; bool b1; int cx,cy; int sz; Printer() &#123; s=""; &#125; bool setColor(COLOR fore,COLOR back=COLOR_BLACK,bool underline=false) &#123; f1=fore; f2=back; bu=underline; return false; &#125; long unsigned int write(const std::string&amp;str) &#123; s+=str; return str.size(); &#125; void writeln() &#123; write("\n"); &#125; bool fresh() &#123; cout&lt;&lt;s&lt;&lt;endl; return true; &#125; void setCursor(bool show,int size=20) &#123; b1=show; sz=size; &#125; void gotoxy(int x,int y) &#123; cx=x; cy=y; &#125; void clear() &#123; s=""; &#125;&#125;;void wait(int tick) &#123;// while(tick--&gt;0) &#123;&#125;&#125;void setTitle(char title[]) &#123; char cmd[200]=""; sprintf(cmd,"title %s",title); system(cmd);&#125;const char GAME_VERSION[]="小跳蛙魔改版alpha 0.2.6";const char TITLE_FORMAT[]="WoA %s (Round %d %s's turn)";const char*const BRIDGE_EMPTY[16]= &#123;"xx","^^","&lt;&lt;","/-","vv","||","\\-","|-","&gt;&gt;","-\\","--","TT","-/","-|","^_","++"&#125;;const char*const BRIDGE_FULL[16]= &#123;"xx","^^","&lt;&lt;","/=","vv","!!","\\=","|=","&gt;&gt;","=\\","==","TT","=/","=|","^=","++"&#125;;const char LABEL_TITLE[]="Player Atom ";const char SPACE[]=" ";const char*const GAME_END_FORMAT[2]= &#123;"title WoA %s (Game ended. %s won.)","title WoA %s (Game ended. No player won.)"&#125;;const char*const ATOMS_CHAR[21]= &#123;SPACE,".1",".2",".3",".4",".5",".6",".7",".8",".9",".A",".B",".C",".D",".E",".F",".G",".H",".I",".J",".K"&#125;;const char*const SPECIAL_CHARS[]= &#123;"()","~ ","/\\","[]","&lt;&gt;"&#125;;#elif defined(_WIN32)/* Little_Ming */#include&lt;conio.h&gt;#include&lt;windows.h&gt;void initKeyBoard() &#123;&#125; void closeKeyBoard() &#123;&#125; enum COLOR &#123;COLOR_BLACK=0,COLOR_DARK_BLUE=1,COLOR_DARK_GREEN=2,COLOR_DARK_BG=3,COLOR_DARK_RED=4,COLOR_DARK_PURPLE=5,COLOR_DARK_YELLOW=6,COLOR_DARK_WHITE=7,COLOR_GRAY=8,COLOR_BLUE=9,COLOR_GREEN=10,COLOR_BG=11,COLOR_RED=12,COLOR_PURPLE=13,COLOR_YELLOW=14,COLOR_WHITE=15&#125;;HANDLE h1=CreateConsoleScreenBuffer(GENERIC_READ|GENERIC_WRITE,FILE_SHARE_WRITE,NULL,CONSOLE_TEXTMODE_BUFFER,NULL);HANDLE h2=CreateConsoleScreenBuffer(GENERIC_READ|GENERIC_WRITE,FILE_SHARE_WRITE,NULL,CONSOLE_TEXTMODE_BUFFER,NULL);HANDLE*oh[2]= &#123;&amp;h1,&amp;h2&#125;;class Printer &#123; public: static const int CONSOLE_H=MAP_SIZE; static const int CONSOLE_W=MAP_SIZE+55; static const int CONSOLE_SIZE=CONSOLE_H*CONSOLE_W; HANDLE h; SMALL_RECT ALL; COORD ZERO; COORD BR; Printer() &#123; freopen("data.txt","w",stdout); h=CreateConsoleScreenBuffer(GENERIC_READ|GENERIC_WRITE,FILE_SHARE_WRITE,NULL,CONSOLE_TEXTMODE_BUFFER,NULL); ALL.Top=ALL.Left=ZERO.X=ZERO.Y=0; ALL.Bottom=BR.Y=CONSOLE_H; ALL.Right=BR.X=CONSOLE_W; &#125; bool setColor(COLOR fore,COLOR back=COLOR_BLACK,bool underline=false) &#123; return SetConsoleTextAttribute(h,fore|(back&lt;&lt;4)|(underline?COMMON_LVB_UNDERSCORE:0)); &#125; long unsigned int write(const std::string&amp;str) &#123; long unsigned int res; const char*s=str.c_str(); WriteConsole(h,s,strlen(s),&amp;res,NULL); return res; &#125; void writeln() &#123; write("\n"); &#125; bool fresh() &#123; HANDLE&amp;ph=*(oh[1]); CONSOLE_CURSOR_INFO CursorInfo; GetConsoleCursorInfo(h,&amp;CursorInfo); SetConsoleCursorInfo(ph,&amp;CursorInfo); CONSOLE_SCREEN_BUFFER_INFO bufInfo; GetConsoleScreenBufferInfo(h,&amp;bufInfo); SetConsoleCursorPosition(ph,bufInfo.dwCursorPosition); SMALL_RECT all=ALL; CHAR_INFO buf[CONSOLE_SIZE]; bool succ=ReadConsoleOutput(h,buf,BR,ZERO,&amp;all); all=ALL; succ&amp;=WriteConsoleOutput(ph,buf,BR,ZERO,&amp;all); SetConsoleActiveScreenBuffer(ph); std::swap(oh[0],oh[1]); return succ; &#125; void setCursor(bool show,int size=20) &#123; CONSOLE_CURSOR_INFO CursorInfo; GetConsoleCursorInfo(h,&amp;CursorInfo); CursorInfo.dwSize=size; CursorInfo.bVisible=show; SetConsoleCursorInfo(h,&amp;CursorInfo); &#125; void gotoxy(int x,int y) &#123; COORD pos; pos.X=x; pos.Y=y; SetConsoleCursorPosition(h,pos); &#125; void clear() &#123; DWORD cCharsWritten; CONSOLE_SCREEN_BUFFER_INFO csbi; DWORD dwConSize; HANDLE hConsole=h; GetConsoleScreenBufferInfo(hConsole,&amp;csbi); dwConSize=csbi.dwSize.X*csbi.dwSize.Y; FillConsoleOutputCharacter(hConsole,TEXT(' '),dwConSize,ZERO,&amp;cCharsWritten); GetConsoleScreenBufferInfo(hConsole,&amp;csbi); FillConsoleOutputAttribute(hConsole,csbi.wAttributes,dwConSize,ZERO,&amp;cCharsWritten); SetConsoleCursorPosition(hConsole,ZERO); &#125;&#125;;void wait(int tick) &#123;// Sleep(tick*20);&#125;void setTitle(char title[]) &#123; char cmd[200]=""; sprintf(cmd,"title %s",title); system(cmd);&#125;const char GAME_VERSION[]="小跳蛙魔改版α0.2.6";const char TITLE_FORMAT[]="原子战役%s (第%d回合 %s行动)";const char*const BRIDGE_EMPTY[16]= &#123;"×","↑","←","╔","↓","║","╚","╟","→","╗","═","╤","╝","╢","╧","╬"&#125;;const char*const BRIDGE_FULL[16]= &#123;"×","↑","←","┏","↓","┃","┗","┠","→","┓","━","┯","┛","┨","┷","╋"&#125;;const char LABEL_TITLE[]="玩家 原子 ";const char SPACE[]=" ";const char*const GAME_END_FORMAT[2]= &#123;"title 原子战役%s (结束！%s赢了)","title 原子战役%s (结束！没有玩家胜利)"&#125;;const char*const ATOMS_CHAR[21]= &#123;SPACE,"·","‥","∴","∷","⑤","⑥","⑦","⑧","⑨","⑩","⑾","⑿","⒀","⒁","⒂","⒃","⒄","⒅","⒆","⒇"&#125;;const char*const SPECIAL_CHARS[]= &#123;"●","～","△","□","◆"&#125;;#else#include&lt;termios.h&gt;#include&lt;unistd.h&gt;#include&lt;sys/prctl.h&gt;static struct termios initial_settings,new_settings;static int peek_character=-1;void initKeyBoard() &#123; tcgetattr(0,&amp;initial_settings); new_settings=initial_settings; new_settings.c_lflag&amp;=~ICANON; new_settings.c_lflag&amp;=~ECHO; new_settings.c_lflag&amp;=~ISIG; new_settings.c_cc[VMIN]=1; new_settings.c_cc[VTIME]=0; tcsetattr(0,TCSANOW,&amp;new_settings);&#125;void closeKeyBoard() &#123; tcsetattr(0,TCSANOW,&amp;initial_settings); printf("\33[0m");&#125;int kbhit() &#123; char ch; int nread; if(peek_character!=-1)return 1; new_settings.c_cc[VMIN]=0; tcsetattr(0,TCSANOW,&amp;new_settings); nread=read(0,&amp;ch,1); new_settings.c_cc[VMIN]=1; tcsetattr(0,TCSANOW,&amp;new_settings); if(nread==1) &#123; peek_character=ch; return 1; &#125; return 0;&#125;int getch() &#123; char ch; if(peek_character!=-1) &#123; ch=peek_character; peek_character=-1; return ch; &#125; read(0,&amp;ch,1); if(ch=='\003') &#123; closeKeyBoard(); exit(0); &#125; if(ch=='\033') &#123; getch(); char c=getch(); const int res[]= &#123;UP,DOWN,RIGHT,LEFT&#125;; return ARROW*256+res[c-'A']; &#125; return ch;&#125;enum COLOR &#123;COLOR_BLACK=0,COLOR_DARK_BLUE=024,COLOR_DARK_GREEN=022,COLOR_DARK_BG=026,COLOR_DARK_RED=021,COLOR_DARK_PURPLE=025,COLOR_DARK_YELLOW=023,COLOR_DARK_WHITE=027,COLOR_GRAY=010,COLOR_BLUE=004,COLOR_GREEN=002,COLOR_BG=006,COLOR_RED=001,COLOR_PURPLE=005,COLOR_YELLOW=003,COLOR_WHITE=007&#125;;class Printer &#123; public: static const int CONSOLE_H=MAP_SIZE; static const int CONSOLE_W=MAP_SIZE+55; static const int CONSOLE_SIZE=CONSOLE_H*CONSOLE_W; int cursor_x,cursor_y; int cols,rows; bool cursor_show; std::string buf[CONSOLE_H][CONSOLE_W]; std::string ctrl[CONSOLE_H][CONSOLE_W]; Printer() &#123; clear(); cursor_x=cursor_y=-1; cursor_show=true; printf("\033[?25l"); &#125; bool setColor(COLOR fore,COLOR back=COLOR_BLACK,bool underline=false) &#123; char tctrl[200]; int fc=(fore&amp;7)+(fore&amp;020?30:90); int bc=(back&amp;7)+(back&amp;020?40:100); sprintf(tctrl,"\033[0m\033[%d;%d",fc,bc); ctrl[rows][cols]=tctrl; if(underline)ctrl[rows][cols]+=";4"; ctrl[rows][cols]+="m"; return true; &#125; void write(const std::string&amp;str) &#123; buf[rows][cols++]=str; &#125; void writeln() &#123; rows++; cols=0; &#125; void fresh() &#123; std::string res="\033[2J"; for(int i=0; i&lt;CONSOLE_H; i++) &#123; for(int j=0; j&lt;CONSOLE_W; j++) &#123; res+=ctrl[i][j]; if(cursor_show&amp;&amp;i==cursor_y&amp;&amp;j==cursor_x/2) &#123; res+="\033[5m\033[7m"; &#125; if(buf[i][j]=="")break; res+=buf[i][j]; &#125; res+="\033[0m\r\n"; printf("%s",res.c_str()); &#125; &#125; void setCursor(bool show,int size=20) &#123; cursor_show=show; assert(size==size); &#125; void gotoxy(int x,int y) &#123; cursor_x=x; cursor_y=y; &#125; void clear() &#123; for(int i=0; i&lt;CONSOLE_H; i++)for(int j=0; j&lt;CONSOLE_W; j++) &#123; buf[i][j].clear(); ctrl[i][j].clear(); &#125; cols=rows=0; &#125;&#125;;void wait(int tick) &#123;// usleep(tick*20000);&#125;void setTitle(char title[]) &#123; prctl(PR_SET_NAME,title,NULL,NULL,NULL);&#125;const char GAME_VERSION[]="α0.2.6";const char TITLE_FORMAT[]="原子战役%s (第%d回合 %s行动)";const char*const BRIDGE_EMPTY[16]= &#123;"× ","↑ ","← ","╔═","↓ ","║ ","╚═","╟═","→ ","╗ ","══","╤═","╝ ","╢ ","╧═","╬═"&#125;;const char*const BRIDGE_FULL[16]= &#123;"× ","↑ ","←━","┏━","↓ ","┃ ","┗━","┠━","━→","┓ ","━━","┯━","┛ ","┨ ","┷━","╋━"&#125;;const char LABEL_TITLE[]="玩家 原子 ";const char SPACE[]=" ";const char*const GAME_END_FORMAT[2]= &#123;"title 原子战役%s (结束！%s赢了)","title 原子战役%s (结束！没有玩家胜利)"&#125;;const char*const ATOMS_CHAR[21]= &#123;SPACE,"· ","··",":.","::","*5","*6","*7","*8","*9","10","11","12","13","14","15","16","17","18","19","20"&#125;;const char*const SPECIAL_CHARS[]= &#123;"●","～","△ ","□ ","◆ "&#125;;#endifenum TERRAIN &#123;TERRAIN_EMPTY,TERRAIN_SEA,TERRAIN_MOUNTAIN&#125;;enum BUILDING &#123;BUILDING_NONE,BUILDING_BRIDGE,BUILDING_PALACE,BUILDING_TOWER&#125;;enum EVENT_TYPE &#123;EVENT_UPDATE,EVENT_CAPETURE,EVENT_GAMEOVER&#125;;enum PLAYER_TYPE &#123;PLAYER_UNKNOWN,PLAYER_AI,PLAYER_HUMAN&#125;;enum MAP_STYLE_TYPE &#123;MAP_STYLE_DEBUG,MAP_STYLE_ARENA,MAP_STYLE_RIVER,MAP_STYLE_HILL,MAP_STYLE_ISLAND,MAP_STYLE_RING,MAP_STYLE_BOB,MAP_STYLE_CLEAN&#125;;const double persistence=0.50;const int Number_Of_Octaves=4;const int MAX_PLAYERS=8;const COLOR playerColors[MAX_PLAYERS]= &#123;COLOR_RED,COLOR_BLUE,COLOR_GREEN,COLOR_DARK_PURPLE,COLOR_DARK_YELLOW,COLOR_DARK_GREEN,COLOR_DARK_RED,COLOR_BG&#125;;const int dx[]= &#123;-1,0,1,0&#125;;const int dy[]= &#123;0,-1,0,1&#125;;const int LOG[16]= &#123;-1,0,1,-1,2,-1,-1,-1,3,-1,-1,-1,-1,-1,-1,-1&#125;;const bool BRIDGE_IS_CORNER[16]= &#123;false,false,false,true,false,false,true,false,false,true,false,false,true,false,false,false&#125;;const int SPEED_NONE=0;const int SPEED_NOTICKDELAY=1;const int SPEED_NOTICKPRINT=2;const int SPEED_NOROUNDDELAY=4;const int SPEED_NOROUNDPRINT=8;double Noise(int x,int y) &#123; int n=x+y*57; n=(n&lt;&lt;13)^n; return(1.0-((n*(n*n*15731+789221)+1376312589)&amp;0x7fffffff)/1073741824.0);&#125;double SmoothedNoise(int x,int y) &#123; double corners=(Noise(x-1,y-1)+Noise(x+1,y-1)+Noise(x-1,y+1)+Noise(x+1,y+1))/16; double sides=(Noise(x-1,y)+Noise(x+1,y)+Noise(x,y-1)+Noise(x,y+1))/8; double center=Noise(x,y)/4; return corners+sides+center;&#125;double Cosine_Interpolate(double a,double b,double x) &#123; double ft=x*3.1415927; double f=(1-cos(ft))*0.5; return a*(1-f)+b*f;&#125;double InterpolatedNoise(double x,double y) &#123; int integer_X=int(x); double fractional_X=x-integer_X; int integer_Y=int(y); double fractional_Y=y-integer_Y; double v1=SmoothedNoise(integer_X,integer_Y); double v2=SmoothedNoise(integer_X+1,integer_Y); double v3=SmoothedNoise(integer_X,integer_Y+1); double v4=SmoothedNoise(integer_X+1,integer_Y+1); double i1=Cosine_Interpolate(v1,v2,fractional_X); double i2=Cosine_Interpolate(v3,v4,fractional_X); return Cosine_Interpolate(i1,i2,fractional_Y);&#125;double PerlinNoise(double x,double y) &#123; double total=0; double p=persistence; int n=Number_Of_Octaves; for(int i=0; i&lt;n; i++) &#123; double frequency=pow(2,i); double amplitude=pow(p,i); total=total+InterpolatedNoise(x*frequency,y*frequency)*amplitude; &#125; return total;&#125;double rand01() &#123; return 1.0*rand()/RAND_MAX;&#125;class Map;class bigChar &#123; public: std::string s; bigChar() &#123; s=""; &#125; bigChar(const char*str) &#123; s=std::string(str); &#125; void cover(bigChar x) &#123; if(x.s!="")s=x.s; &#125;&#125;;struct Event &#123; int x,y,t,data; EVENT_TYPE type; Event(int _x,int _y,int _t,EVENT_TYPE _type,int _data) &#123; x=_x; y=_y; t=_t; type=_type; data=_data; &#125; bool operator&lt;(const Event e)const &#123; if(t!=e.t)return t&gt;e.t; if(x!=e.x)return x&gt;e.x; if(y!=e.y)return y&gt;e.y; return false; &#125;&#125;;class Map &#123; public: Printer*p; TERRAIN ter[MAP_SIZE][MAP_SIZE]; BUILDING building[MAP_SIZE][MAP_SIZE]; int data[MAP_SIZE][MAP_SIZE]; int atoms[MAP_SIZE][MAP_SIZE]; int atomFlags[MAP_SIZE][MAP_SIZE][4]; int owner[MAP_SIZE][MAP_SIZE]; bool alive[MAX_PLAYERS]; int palacesx[MAX_PLAYERS]; int palacesy[MAX_PLAYERS]; vector&lt;int&gt;towersx,towersy; PLAYER_TYPE playerType[MAX_PLAYERS]; const char*playerNames[MAX_PLAYERS]; int atomsCount[MAX_PLAYERS]; int landCount[MAX_PLAYERS]; int size; int cx,cy; int speed; int playerCount; priority_queue&lt;Event&gt;eventQueue; int tick; Map(int _size) &#123; size=_size; cx=cy=size/2; for(int x=0; x&lt;size; x++) &#123; for(int y=0; y&lt;size; y++) &#123; building[x][y]=BUILDING_NONE; data[x][y]=0; atoms[x][y]=0; for(int der=0; der&lt;4; der++)atomFlags[x][y][der]=0; owner[x][y]=-1; &#125; &#125; towersx.clear(); towersy.clear(); speed=0; &#125; const bigChar getTerChars(int x,int y); const bigChar getBuildingChars(int x,int y); bool isUnderline(int x,int y); COLOR getForeColor(int x,int y); COLOR getBackColor(int x,int y); bool atomAccessable(int x,int y,int der); int atomLimit(int x,int y); bool hasEvent() &#123; return!eventQueue.empty(); &#125; void doGameTick(); void sendAtoms(int x,int y,int der,int tick,int owner,int count); void updateGrid(Event e); void setPalace(int x,int y,int id); void setTower(int x,int y,int id,int count,int speed); void setBridge(int x,int y,int n,int w,int s,int e); void towersProduce(int id); void buildMap(MAP_STYLE_TYPE style,int players); void gameCount() &#123; memset(landCount,0,sizeof(landCount)); memset(atomsCount,0,sizeof(atomsCount)); for(int i=0; i&lt;size; i++)for(int j=0; j&lt;size; j++) &#123; int to=owner[i][j]; if(to&gt;=0) &#123; landCount[to]++; atomsCount[to]+=atoms[i][j]; &#125; &#125; &#125; void resetEvent() &#123; tick=0; while(hasEvent())eventQueue.pop(); &#125; bool inBound(int x,int y) &#123; return x&gt;=0&amp;&amp;x&lt;size&amp;&amp;y&gt;=0&amp;&amp;y&lt;size; &#125; void print() &#123; p-&gt;clear(); gameCount(); for(int i=-SCREEN_SIZE; i&lt;=SCREEN_SIZE; i++) &#123; for(int j=-SCREEN_SIZE; j&lt;=SCREEN_SIZE; j++) &#123; int x=cx+i; int y=cy+j; if(!inBound(x,y)) &#123; p-&gt;setColor(COLOR_BLACK,COLOR_BLACK); p-&gt;write(SPACE); continue; &#125; p-&gt;setColor(getForeColor(x,y),getBackColor(x,y),isUnderline(x,y)); bigChar ch=getTerChars(x,y); ch.cover(getBuildingChars(x,y)); p-&gt;write(ch.s); &#125; int line=i+SCREEN_SIZE; if(line==0) &#123; p-&gt;setColor(COLOR_BLACK,COLOR_WHITE); p-&gt;write(LABEL_TITLE); &#125; else if(line-1&gt;=0&amp;&amp;line-1&lt;playerCount) &#123; p-&gt;setColor(alive[line-1]?playerColors[line-1]:COLOR_BLACK,COLOR_WHITE); char rw[60]=""; sprintf(rw,"%-6s %-6d",playerNames[line-1],atomsCount[line-1]); p-&gt;write(rw); &#125; p-&gt;setColor(COLOR_BLACK,COLOR_BLACK); if(i&lt;SCREEN_SIZE)p-&gt;writeln(); &#125; p-&gt;fresh(); &#125; bool moveCursor(int x,int y) &#123; if(!inBound(x,y))return false; int hx=(y-cy+SCREEN_SIZE)*2; int hy=x-cx+SCREEN_SIZE; p-&gt;gotoxy(hx,hy); p-&gt;fresh(); return true; &#125; bool isEnded() &#123; int ali=0; gameCount(); for(int i=0; i&lt;playerCount; i++)if(alive[i]||landCount[i]&gt;0) &#123; ali++; &#125; if(ali&lt;=1)return true; else return false; &#125; int getWinner() &#123; if(!isEnded())return-2; for(int i=0; i&lt;playerCount; i++)if(alive[i]) &#123; return i; &#125; return-1; &#125; void progress() &#123; while(kbhit())getch(); while(hasEvent()) &#123; if((speed&amp;SPEED_NOTICKDELAY)==0)wait(1); doGameTick(); if((speed&amp;SPEED_NOTICKPRINT)==0)print(); &#125; if((speed&amp;SPEED_NOROUNDPRINT)==0)print(); if((speed&amp;SPEED_NOROUNDDELAY)==0)wait(3); if(isEnded()) &#123; char cmd[200]=""; int winner=getWinner(); if(winner!=-1) &#123; sprintf(cmd,GAME_END_FORMAT[0],GAME_VERSION,playerNames[winner]); &#125; else &#123; sprintf(cmd,GAME_END_FORMAT[1],GAME_VERSION); &#125; system(cmd); print(); closeKeyBoard(); exit(0); &#125; &#125; bool choiceVaild(int x,int y,int id) &#123; return inBound(x,y)&amp;&amp;owner[x][y]==id&amp;&amp;(building[x][y]==BUILDING_NONE||building[x][y]==BUILDING_PALACE); &#125;&#125;;const bigChar Map::getTerChars(int x,int y) &#123; switch(ter[x][y]) &#123; case TERRAIN_EMPTY: &#123; int k=atoms[x][y]; if(k&lt;=20)return bigChar(ATOMS_CHAR[k]); else return bigChar(SPECIAL_CHARS[0]); break; &#125; case TERRAIN_SEA: &#123; return bigChar((x+y)%2?SPACE:SPECIAL_CHARS[1]); break; &#125; case TERRAIN_MOUNTAIN: &#123; return bigChar(SPECIAL_CHARS[2]); break; &#125; &#125; return bigChar(SPACE);&#125;const bigChar Map::getBuildingChars(int x,int y) &#123; switch(building[x][y]) &#123; case BUILDING_NONE: &#123; return bigChar(""); break; &#125; case BUILDING_BRIDGE: &#123; return bigChar((atoms[x][y]==0?BRIDGE_EMPTY:BRIDGE_FULL)[data[x][y]&amp;15]); break; &#125; case BUILDING_PALACE: &#123; if(atoms[x][y]&gt;0)return bigChar(""); else return bigChar(SPECIAL_CHARS[3]); break; &#125; case BUILDING_TOWER: &#123; if(atoms[x][y]&gt;0)return bigChar(""); else return bigChar(SPECIAL_CHARS[4]); break; &#125; &#125; return bigChar(SPACE);&#125;bool Map::isUnderline(int x,int y) &#123; return building[x][y]==BUILDING_PALACE;&#125;COLOR Map::getForeColor(int x,int y) &#123; switch(building[x][y]) &#123; case BUILDING_BRIDGE: &#123; if(owner[x][y]==-1)if(ter[x][y]==TERRAIN_MOUNTAIN)return COLOR_BLACK; else return COLOR_GRAY; else return playerColors[owner[x][y]]; break; &#125; case BUILDING_PALACE: &#123; return COLOR_YELLOW; break; &#125; case BUILDING_TOWER: &#123; return COLOR_PURPLE; break; &#125; case BUILDING_NONE: &#123; break; &#125; &#125; switch(ter[x][y]) &#123; case TERRAIN_EMPTY: &#123; return COLOR_WHITE; break; &#125; case TERRAIN_MOUNTAIN: &#123; return COLOR_BLACK; break; &#125; case TERRAIN_SEA: &#123; return COLOR_DARK_BG; break; &#125; &#125; return COLOR_BLACK;&#125;COLOR Map::getBackColor(int x,int y) &#123; switch(building[x][y]) &#123; case BUILDING_PALACE: case BUILDING_TOWER: &#123; if(owner[x][y]==-1)return COLOR_GRAY; else if(owner[x][y]==-2)return COLOR_BLACK; else return playerColors[owner[x][y]]; return COLOR_WHITE; break; &#125; case BUILDING_NONE: &#123; break; &#125; case BUILDING_BRIDGE: &#123; if(ter[x][y]==TERRAIN_EMPTY)return COLOR_WHITE; break; &#125; &#125; switch(ter[x][y]) &#123; case TERRAIN_EMPTY: &#123; if(owner[x][y]==-1)return atoms[x][y]&gt;0?COLOR_GRAY:COLOR_WHITE; else if(owner[x][y]==-2)return atoms[x][y]&gt;0?COLOR_BLACK:COLOR_WHITE; else return playerColors[owner[x][y]]; return COLOR_WHITE; break; &#125; case TERRAIN_MOUNTAIN: &#123; return COLOR_DARK_WHITE; break; &#125; case TERRAIN_SEA: &#123; return COLOR_DARK_BLUE; break; &#125; &#125; return COLOR_BLACK;&#125;bool Map::atomAccessable(int x,int y,int der) &#123; switch(building[x][y]) &#123; case BUILDING_NONE: &#123; break; &#125; case BUILDING_BRIDGE: &#123; return(data[x][y]&amp;(1&lt;&lt;der))!=0?1:0; &#125; case BUILDING_TOWER: case BUILDING_PALACE: &#123; return true; &#125; &#125; switch(ter[x][y]) &#123; case TERRAIN_SEA: case TERRAIN_EMPTY: &#123; return true; &#125; case TERRAIN_MOUNTAIN: &#123; return false; &#125; &#125; return false;&#125;int Map::atomLimit(int x,int y) &#123; int res=0; for(int der=0; der&lt;4; der++) &#123; if(atomAccessable(x+dx[der],y+dy[der],der)) &#123; res++; &#125; &#125; return res;&#125;void Map::doGameTick() &#123; while(hasEvent()&amp;&amp;(eventQueue.top().t&lt;=tick||eventQueue.top().type==EVENT_GAMEOVER)) &#123; Event e=eventQueue.top(); eventQueue.pop(); switch(e.type) &#123; case EVENT_UPDATE: &#123; updateGrid(e); break; &#125; case EVENT_CAPETURE: &#123; owner[e.x][e.y]=e.data; break; &#125; case EVENT_GAMEOVER: &#123; resetEvent(); return; &#125; &#125; &#125; tick++;&#125;void Map::sendAtoms(int x,int y,int der,int tick,int aOwner,int count) &#123; if(der!=-1)atomFlags[x][y][der]+=count; switch(building[x][y]) &#123; case BUILDING_TOWER: case BUILDING_NONE: &#123; break; &#125; case BUILDING_BRIDGE: &#123; goto ok; break; &#125; case BUILDING_PALACE: &#123; if(aOwner!=owner[x][y]&amp;&amp;owner[x][y]==data[x][y]) &#123; alive[data[x][y]]=false; for(int i=0; i&lt;size; i++)for(int j=0; j&lt;size; j++) &#123; if(owner[i][j]==data[x][y]) &#123; eventQueue.push(Event(i,j,tick+(abs(i-x)+abs(j-y))*2,EVENT_CAPETURE,aOwner)); &#125; &#125; building[x][y]=BUILDING_NONE; data[x][y]=0; &#125; if(isEnded()) &#123; eventQueue.push(Event(-1,-1,tick+256,EVENT_GAMEOVER,0)); &#125; &#125; &#125; switch(ter[x][y]) &#123; case TERRAIN_EMPTY: &#123; break; &#125; case TERRAIN_MOUNTAIN: case TERRAIN_SEA: &#123; return; &#125; &#125;ok: ; if(owner[x][y]!=-2) &#123; owner[x][y]=aOwner; atoms[x][y]+=count; &#125; else &#123; if(count&gt;atoms[x][y]) &#123; owner[x][y]=aOwner; atoms[x][y]=count-atoms[x][y]; &#125; else &#123; atoms[x][y]-=count; &#125; &#125; eventQueue.push(Event(x,y,tick+2,EVENT_UPDATE,0));&#125;void Map::updateGrid(Event e) &#123; int x=e.x; int y=e.y; switch(building[x][y]) &#123; case BUILDING_PALACE: case BUILDING_TOWER: case BUILDING_NONE: &#123; break; &#125; case BUILDING_BRIDGE: &#123; if(atoms[x][y]&lt;=0)return; int d=data[x][y]; for(int der=0; der&lt;4; der++) &#123; if(atomFlags[x][y][der]) &#123; int newDer=der; if(BRIDGE_IS_CORNER[d])newDer=2^LOG[d^(1&lt;&lt;der)]; atoms[x][y]-=atomFlags[x][y][der]; sendAtoms(x+dx[newDer],y+dy[newDer],newDer,e.t+1,owner[x][y],atomFlags[x][y][der]); &#125; atomFlags[x][y][der]=0; &#125; return; &#125; &#125; switch(ter[x][y]) &#123; case TERRAIN_EMPTY: &#123; int oks=atomLimit(x,y); if(owner[x][y]!=-2&amp;&amp;oks&gt;=1&amp;&amp;atoms[x][y]&gt;=oks) &#123; int splited=atoms[x][y]/oks; for(int der=0; der&lt;4; der++) &#123; if(atomAccessable(x+dx[der],y+dy[der],der)) &#123; atoms[x][y]-=splited; sendAtoms(x+dx[der],y+dy[der],der,e.t+2,owner[x][y],splited); &#125; &#125; &#125; &#125; case TERRAIN_SEA: case TERRAIN_MOUNTAIN: &#123; return; &#125; &#125;&#125;void Map::towersProduce(int id) &#123; int l=towersx.size(); for(int i=0; i&lt;l; i++) &#123; int tx=towersx[i]; int ty=towersy[i]; if(building[tx][ty]==BUILDING_TOWER&amp;&amp;owner[tx][ty]==id)sendAtoms(tx,ty,-1,0,id,data[tx][ty]); &#125;&#125;void Map::setPalace(int x,int y,int id) &#123; ter[x][y]=TERRAIN_EMPTY; owner[x][y]=id; building[x][y]=BUILDING_PALACE; data[x][y]=id; palacesx[id]=x; palacesy[id]=y;&#125;void Map::setTower(int x,int y,int id,int count,int speed=1) &#123; owner[x][y]=id; atoms[x][y]=count; building[x][y]=BUILDING_TOWER; data[x][y]=speed; towersx.push_back(x); towersy.push_back(y);&#125;void Map::setBridge(int x,int y,int n,int w,int s,int e) &#123; building[x][y]=BUILDING_BRIDGE; data[x][y]=(n&lt;&lt;0)|(w&lt;&lt;1)|(s&lt;&lt;2)|(e&lt;&lt;3);&#125;void Map::buildMap(MAP_STYLE_TYPE style,int players) &#123; towersx.clear(); towersy.clear(); playerCount=players; switch(style) &#123; case MAP_STYLE_DEBUG: &#123; int posesx[]= &#123;2,2,size-3,size-3,2,size/2,size/2,size-3,size/2&#125;; int posesy[]= &#123;2,size-3,2,size-3,size/2,2,size-3,size/2,size/2&#125;; for(int x=0; x&lt;size; x++) &#123; for(int y=0; y&lt;size; y++) &#123; ter[x][y]=(x==0||x==size-1||y==0||y==size-1)?TERRAIN_MOUNTAIN:TERRAIN_EMPTY; &#125; &#125; for(int x=0; x&lt;size; x++) &#123; for(int y=0; y&lt;size; y++) &#123; if(ter[x][y]==TERRAIN_EMPTY) &#123; setTower(x,y,-2,rand()%3+1); &#125; &#125; &#125; for(int id=0; id&lt;players; id++) &#123; setPalace(posesx[id],posesy[id],id); atoms[posesx[id]][posesy[id]]=0; &#125; break; &#125; case MAP_STYLE_ARENA: &#123; int mx=rand(); int my=rand(); for(int x=0; x&lt;size; x++) &#123; for(int y=0; y&lt;size; y++) &#123; if(min(min(x,y),min(size-1-x,size-1-y))+PerlinNoise(x+mx,y+my)&lt;=1)ter[x][y]=TERRAIN_MOUNTAIN; else ter[x][y]=TERRAIN_EMPTY; &#125; &#125; for(int x=4; x&lt;=size-5; x++) &#123; building[x][size/2]=BUILDING_BRIDGE; data[x][size/2]|=((1&lt;&lt;0)|(1&lt;&lt;2)); &#125; for(int y=4; y&lt;=size-5; y++) &#123; building[size/2][y]=BUILDING_BRIDGE; data[size/2][y]|=((1&lt;&lt;1)|(1&lt;&lt;3)); &#125; for(int x=size/2-1; x&lt;=size/2+1; x++) &#123; for(int y=size/2-1; y&lt;=size/2+1; y++) &#123; building[x][y]=BUILDING_NONE; data[x][y]=0; &#125; &#125; setTower(size/2,size/2,-2,(players)/2-rand()%2); int c=(size-5)*4; int start=rand()%c; for(int id=0; id&lt;players; id++) &#123; int pos=(start+id*c/players)%c; int dpos=pos%(c/4); if(0&lt;=pos&amp;&amp;pos&lt;c/4)setPalace(2,dpos+2,id); if(c/4&lt;=pos&amp;&amp;pos&lt;c/2)setPalace(dpos+2,size-3,id); if(c/2&lt;=pos&amp;&amp;pos&lt;c/4*3)setPalace(size-3,size-3-dpos,id); if(c/4*3&lt;=pos&amp;&amp;pos&lt;c)setPalace(size-3-dpos,2,id); &#125; break; &#125; case MAP_STYLE_RIVER: &#123; int mx=rand(); int my=rand(); for(int x=0; x&lt;size; x++) &#123; for(int y=0; y&lt;size; y++) &#123; if(min(min(x,y),min(size-1-x,size-1-y))+PerlinNoise(x+mx,y+my)&lt;=1)ter[x][y]=TERRAIN_MOUNTAIN; else ter[x][y]=TERRAIN_EMPTY; &#125; &#125; for(int y=0; y&lt;size; y++) &#123; for(int x=size/2-1; x&lt;=size/2+1; x++)if(ter[x][y]==TERRAIN_EMPTY&amp;&amp;abs(size/2-x)+PerlinNoise(x+mx,y+my)&lt;1.2) &#123; ter[x][y]=TERRAIN_SEA; &#125; &#125; int mustBuild=rand()%(size-6)+3; int setWait=0; for(int y=3; y&lt;=size-4; y++) &#123; if(setWait&lt;=0&amp;&amp;(y==mustBuild||rand()%4==0)) &#123; for(int x=size/2-2; x&lt;=size/2+2; x++) &#123; building[x][y]=BUILDING_BRIDGE; data[x][y]|=((1&lt;&lt;0)|(1&lt;&lt;2)); &#125; setWait=3; &#125; setWait--; &#125; int c=(size-6)*2; int start=rand()%c; for(int id=0; id&lt;players; id++) &#123; int pos=(start+id*c/players)%c; int dpos=pos%(c/2); if(0&lt;=pos&amp;&amp;pos&lt;c/2)setPalace(3,dpos+3,id); if(c/2&lt;=pos&amp;&amp;pos&lt;c)setPalace(size-4,size-4-dpos,id); &#125; break; &#125; case MAP_STYLE_HILL: &#123; int mx=rand(); int my=rand(); for(int x=0; x&lt;size; x++) &#123; for(int y=0; y&lt;size; y++) &#123; if(min(min(x,y),min(size-1-x,size-1-y))+PerlinNoise(x+mx,y+my)&lt;=2)ter[x][y]=TERRAIN_MOUNTAIN; else ter[x][y]=TERRAIN_EMPTY; &#125; &#125; for(int x=4; x&lt;=size-5; x++) &#123; for(int y=4; y&lt;=size-5; y++) &#123; if(PerlinNoise(x+mx,y+my)&lt;=0) &#123; ter[x][y]=TERRAIN_MOUNTAIN; &#125; &#125; &#125; int tb=(size+1)*3/4; for(int i=0; i&lt;tb; i++) &#123; int bx=rand()%(size-10)+5; int by=rand()%(size-10)+5; int d[2]; d[0]=i%4; d[1]=d[0]^2; for(int di=0; di&lt;2; di++) &#123; int nx=bx; int ny=by; while(inBound(nx,ny)&amp;&amp;ter[nx][ny]==TERRAIN_MOUNTAIN) &#123; building[nx][ny]=BUILDING_BRIDGE; data[nx][ny]|=(1&lt;&lt;(d[0]))|(1&lt;&lt;(d[1])); nx+=dx[d[di]]; ny+=dy[d[di]]; &#125; &#125; &#125; int c=(size-5)*4; int start=rand()%c; for(int id=0; id&lt;players; id++) &#123; int pos=(start+id*c/players)%c; int dpos=pos%(c/4); if(dpos%(size-5)==0)dpos++; dpos%=c; if(0&lt;=pos&amp;&amp;pos&lt;c/4)setPalace(2,dpos+2,id); if(c/4&lt;=pos&amp;&amp;pos&lt;c/2)setPalace(dpos+2,size-3,id); if(c/2&lt;=pos&amp;&amp;pos&lt;c/4*3)setPalace(size-3,size-3-dpos,id); if(c/4*3&lt;=pos&amp;&amp;pos&lt;c)setPalace(size-3-dpos,2,id); &#125; break; &#125; case MAP_STYLE_BOB: &#123; int c=(size-5)*4; int start=rand()%c; for(int id=0; id&lt;players; id++) &#123; int pos=(start+id*c/players)%c; int dpos=pos%(c/4); if(dpos%(size-5)==0)dpos++; dpos%=c; if(0&lt;=pos&amp;&amp;pos&lt;c/4) &#123; setPalace(2,dpos+2,id); setTower(2,dpos+1,-2,rand()%2); setTower(2,dpos+3,-2,rand()%2); setTower(3,dpos+1,-2,rand()%2); setTower(3,dpos+2,-2,rand()%2); setTower(3,dpos+3,-2,rand()%2); &#125; if(c/4&lt;=pos&amp;&amp;pos&lt;c/2) &#123; setPalace(dpos+2,size-3,id); setTower(dpos+1,size-4,-2,rand()%2); setTower(dpos+1,size-3,-2,rand()%2); setTower(dpos+2,size-4,-2,rand()%2); setTower(dpos+3,size-4,-2,rand()%2); setTower(dpos+3,size-3,-2,rand()%2); &#125; if(c/2&lt;=pos&amp;&amp;pos&lt;c/4*3) &#123; setPalace(size-3,size-3-dpos,id); setTower(size-4,size-4-dpos,-2,rand()%2); setTower(size-4,size-3-dpos,-2,rand()%2); setTower(size-4,size-2-dpos,-2,rand()%2); setTower(size-3,size-4-dpos,-2,rand()%2); setTower(size-3,size-2-dpos,-2,rand()%2); &#125; if(c/4*3&lt;=pos&amp;&amp;pos&lt;c) &#123; setPalace(size-3-dpos,2,id); setTower(size-4-dpos,2,-2,rand()%2); setTower(size-4-dpos,3,-2,rand()%2); setTower(size-3-dpos,3,-2,rand()%2); setTower(size-2-dpos,2,-2,rand()%2); setTower(size-2-dpos,3,-2,rand()%2); &#125; &#125; int mx=rand(); int my=rand(); for(int x=0; x&lt;size; x++) &#123; for(int y=0; y&lt;size; y++) &#123; if(min(min(x,y),min(size-1-x,size-1-y))+PerlinNoise(x+mx,y+my)&lt;=1&amp;&amp;building[x][y]!=BUILDING_TOWER&amp;&amp;building[x][y]!=BUILDING_PALACE)ter[x][y]=TERRAIN_MOUNTAIN; else ter[x][y]=TERRAIN_EMPTY; &#125; &#125; for(int x=4; x&lt;=size-5; x++) &#123; for(int y=4; y&lt;=size-5; y++) &#123; if(PerlinNoise(x+mx,y+my)&lt;=0&amp;&amp;building[x][y]!=BUILDING_TOWER&amp;&amp;building[x][y]!=BUILDING_PALACE) &#123; ter[x][y]=TERRAIN_MOUNTAIN; &#125; &#125; &#125; break; &#125; case MAP_STYLE_CLEAN: &#123; int c=(size-5)*4; int start=rand()%c; for(int x=0; x&lt;size; x++) &#123; for(int y=0; y&lt;size; y++) &#123; if(min(min(x,y),min(size-1-x,size-1-y))&lt;=0)ter[x][y]=TERRAIN_MOUNTAIN; else ter[x][y]=TERRAIN_EMPTY; &#125; &#125; for(int x=3; x&lt;=size/2-2; x++) &#123; building[x][size/2]=BUILDING_BRIDGE; data[x][size/2]|=((1&lt;&lt;0)|(1&lt;&lt;2)); &#125; for(int x=size/2+2; x&lt;=size-4; x++) &#123; building[x][size/2]=BUILDING_BRIDGE; data[x][size/2]|=((1&lt;&lt;0)|(1&lt;&lt;2)); &#125; for(int y=3; y&lt;=size/2-2; y++) &#123; building[size/2][y]=BUILDING_BRIDGE; data[size/2][y]|=((1&lt;&lt;1)|(1&lt;&lt;3)); &#125; for(int y=size/2+2; y&lt;=size-4; y++) &#123; building[size/2][y]=BUILDING_BRIDGE; data[size/2][y]|=((1&lt;&lt;1)|(1&lt;&lt;3)); &#125; setTower(size/2,size/2,-1,0); setTower(size/2-1,size/2,-2,2); setTower(size/2+1,size/2,-2,2); setTower(size/2,size/2-1,-2,2); setTower(size/2,size/2+1,-2,2); for(int x=3;x&lt;=size-4;x++) if(building[x][3]!=BUILDING_BRIDGE&amp;&amp;building[x][3]!=BUILDING_TOWER) ter[x][3]=TERRAIN_MOUNTAIN; for(int x=3;x&lt;=size-4;x++) if(building[x][size-4]!=BUILDING_BRIDGE&amp;&amp;building[x][size-4]!=BUILDING_TOWER) ter[x][size-4]=TERRAIN_MOUNTAIN; for(int y=3;y&lt;=size-4;y++) if(building[3][y]!=BUILDING_BRIDGE&amp;&amp;building[3][y]!=BUILDING_TOWER) ter[3][y]=TERRAIN_MOUNTAIN; for(int y=3;y&lt;=size-4;y++) if(building[size-4][y]!=BUILDING_BRIDGE&amp;&amp;building[size-4][y]!=BUILDING_TOWER) ter[size-4][y]=TERRAIN_MOUNTAIN; for(int id=0; id&lt;players; id++) &#123; int pos=(start+id*c/players)%c; int dpos=pos%(c/4); if(dpos%(size-5)==0)dpos++; dpos%=c; if(0&lt;=pos&amp;&amp;pos&lt;c/4) setPalace(1,dpos+1,id); if(c/4&lt;=pos&amp;&amp;pos&lt;c/2) setPalace(dpos+1,size-2,id); if(c/2&lt;=pos&amp;&amp;pos&lt;c/4*3) setPalace(size-2,size-2-dpos,id); if(c/4*3&lt;=pos&amp;&amp;pos&lt;c) setPalace(size-2-dpos,1,id); &#125; // for(int x=3; x&lt;=size-4; x++) &#123; // for(int y=3; y&lt;=size-4; y++) &#123; // if(building[x][y]!=BUILDING_PALACE) &#123; // ter[x][y]=TERRAIN_MOUNTAIN; // &#125; // &#125; // &#125; break; &#125; case MAP_STYLE_ISLAND: &#123; int mx=rand(); int my=rand(); for(int x=0; x&lt;size; x++) &#123; for(int y=0; y&lt;size; y++) &#123; if(min(min(x,y),min(size-1-x,size-1-y))+PerlinNoise(x+mx,y+my)&lt;=1)ter[x][y]=TERRAIN_SEA; else ter[x][y]=TERRAIN_EMPTY; &#125; &#125; setTower(size/2,size/2,-1,0,2); setBridge(size/2+1,size/2,0,0,1,0); setBridge(size/2-1,size/2,1,0,0,0); setBridge(size/2,size/2+1,0,0,0,1); setBridge(size/2,size/2-1,0,1,0,0); setTower(size/2-5,size/2-5,-2,4); setTower(size/2-5,size/2+5,-2,4); setTower(size/2+5,size/2-5,-2,4); setTower(size/2+5,size/2+5,-2,4); int c=(size-7)*4; int start=rand()%c; for(int id=0; id&lt;players; id++) &#123; int pos=(start+id*c/players)%c; int dpos=pos%(c/4); if(0&lt;=pos&amp;&amp;pos&lt;c/4)setPalace(3,dpos+3,id); if(c/4&lt;=pos&amp;&amp;pos&lt;c/2)setPalace(dpos+3,size-4,id); if(c/2&lt;=pos&amp;&amp;pos&lt;c/4*3)setPalace(size-4,size-4-dpos,id); if(c/4*3&lt;=pos&amp;&amp;pos&lt;c)setPalace(size-4-dpos,3,id); &#125; break; break; &#125; case MAP_STYLE_RING: &#123; int mx=rand(); int my=rand();#define tryBridge(x,y,n,w,s,e,r) do&#123;if(PerlinNoise(x+mx,y+my)&lt;=r)setBridge(x,y,n,w,s,e);&#125;while(0)#define genRing(_x,_r) do&#123;int x(_x);double r(_r);tryBridge(x,x,1,1,0,0,r);tryBridge(x,size-1-x,1,0,0,1,r);tryBridge(size-1-x,x,0,1,1,0,r);tryBridge(size-1-x,size-1-x,0,0,1,1,r);for(int i=x+1;i&lt;size-1-x;i++)&#123;if(i==size/2&amp;&amp;r&lt;1)continue;tryBridge(x,i,0,1,0,1,r);tryBridge(size-1-x,i,0,1,0,1,r);tryBridge(i,x,1,0,1,0,r);tryBridge(i,size-1-x,1,0,1,0,r);&#125;&#125;while(0) genRing(0,1); for(int i=5; i+2&lt;=size/2; i+=5) &#123; genRing(i,(double)i*0.5/size); &#125; for(int i=size/2-1; i&lt;=size/2+1; i++) &#123; for(int j=size/2-1; j&lt;=size/2+1; j++) &#123; bool isE=i==size/2&amp;&amp;j==size/2; setTower(i,j,isE?-1:-2,isE?0:4); &#125; &#125; int c=(size-5)*4; int start=rand()%c; for(int id=0; id&lt;players; id++) &#123; int pos=(start+id*c/players)%c; int dpos=pos%(c/4); if(0&lt;=pos&amp;&amp;pos&lt;c/4)setPalace(2,dpos+2,id); if(c/4&lt;=pos&amp;&amp;pos&lt;c/2)setPalace(dpos+2,size-3,id); if(c/2&lt;=pos&amp;&amp;pos&lt;c/4*3)setPalace(size-3,size-3-dpos,id); if(c/4*3&lt;=pos&amp;&amp;pos&lt;c)setPalace(size-3-dpos,2,id); &#125; break;#undef genRing &#125; &#125; for(int i=0; i&lt;players; i++) &#123; alive[i]=true; playerType[i]=PLAYER_UNKNOWN; &#125;&#125;double dfs(Map*map,int id,int&amp;x,int&amp;y,bool help,int dep,double alpha,double beta) &#123; if(dep&lt;=0) &#123; if(map-&gt;isEnded()) &#123; return map-&gt;getWinner()==id?(1&lt;&lt;30):-(1&lt;&lt;30); &#125; map-&gt;gameCount(); double score=0; for(int i=0; i&lt;map-&gt;playerCount; i++) &#123; int s=i==id?1:-1; score+=s*(1.0*map-&gt;atomsCount[i]+1.0*map-&gt;landCount[i]); if(map-&gt;alive[i]) &#123; for(int dx=-3; dx&lt;=3; dx++) &#123; int ry=3-abs(dx); for(int dy=-ry; dy&lt;=ry; dy++) &#123; int tx=map-&gt;palacesx[i]+dx; int ty=map-&gt;palacesy[i]+dy; if(map-&gt;inBound(tx,ty)) &#123; int o=map-&gt;owner[tx][ty]; if(o&gt;=0) &#123; score+=(o==id?1e4:-1e4)/(abs(dx)+abs(dy)+1); &#125; &#125; &#125; &#125; &#125; &#125; return score; &#125; x=-1; y=-1; double score; double score1d=-(1&lt;&lt;30); double rnd=1.0; if(help)score=-(1&lt;&lt;30); else score=(1&lt;&lt;30); for(int i=0; i&lt;map-&gt;size; i++)for(int j=0; j&lt;map-&gt;size; j++) &#123; bool ok=false; if(help)ok=map-&gt;choiceVaild(i,j,id); else &#123; for(int tid=0; tid&lt;MAX_PLAYERS; tid++) &#123; if(tid!=id&amp;&amp;map-&gt;choiceVaild(i,j,tid))ok=true; &#125; &#125; if(!ok)continue; int pl=map-&gt;owner[i][j]; Map tmap(*map); if(!help) &#123; int npl=(id+1)%tmap.playerCount; while(npl!=pl) &#123; if(npl==0) &#123; tmap.resetEvent(); tmap.towersProduce(-1); while(tmap.hasEvent())tmap.doGameTick(); &#125; tmap.resetEvent(); tmap.towersProduce(npl); while(tmap.hasEvent())tmap.doGameTick(); npl=(npl+1)%tmap.playerCount; &#125; &#125; tmap.resetEvent(); tmap.towersProduce(pl); while(tmap.hasEvent())tmap.doGameTick(); tmap.resetEvent(); tmap.sendAtoms(i,j,-1,0,pl,1); while(tmap.hasEvent())tmap.doGameTick(); if(!help) &#123; int npl=(pl+1)%tmap.playerCount; while(npl!=id) &#123; if(npl==0) &#123; tmap.resetEvent(); tmap.towersProduce(-1); while(tmap.hasEvent())tmap.doGameTick(); &#125; tmap.resetEvent(); tmap.towersProduce(npl); while(tmap.hasEvent())tmap.doGameTick(); npl=(npl+1)%tmap.playerCount; &#125; &#125; tmap.resetEvent(); tmap.towersProduce(id); while(tmap.hasEvent())tmap.doGameTick(); int tx,ty; double newScore=dfs(&amp;tmap,id,tx,ty,!help,dep-1,alpha,beta); double new1d; double trnd=rand01(); bool cha=false; if(help) &#123; cha=newScore&gt;score; if(newScore==score) &#123; Map dmap(*map); int less=dmap.atomLimit(i,j)-dmap.atoms[i][j]; dmap.resetEvent(); dmap.sendAtoms(i,j,-1,0,id,less); while(dmap.hasEvent())dmap.doGameTick(); int tx,ty; new1d=(dfs(&amp;dmap,id,tx,ty,true,0,alpha,beta)-dfs(map,id,tx,ty,true,0,alpha,beta))/less; if(new1d&gt;score1d)cha=true; else if(new1d==score1d) &#123; cha=trnd&gt;rnd; &#125; &#125; &#125; else cha=newScore&lt;score||(newScore==score&amp;&amp;trnd&gt;rnd); if(cha) &#123; x=i; y=j; score=newScore; if(help)score1d=new1d; rnd=trnd; &#125; if(help) &#123; if(score&gt;alpha) &#123; alpha=score; if(alpha&gt;=beta)goto end; &#125; &#125; else &#123; if(score&lt;beta) &#123; beta=score; if(beta&lt;=alpha)goto end; &#125; &#125; &#125;end: ; return score;&#125;double AILV[MAX_PLAYERS];void AI(Map*map,int id,int&amp;x,int&amp;y) &#123; bool mistake=rand01()&gt;AILV[id]; dfs(map,id,x,y,true,mistake?1:2,-(1&lt;&lt;30),(1&lt;&lt;30));&#125;int cursorx[MAX_PLAYERS];int cursory[MAX_PLAYERS];void decide(Map*map,int id,int&amp;x,int&amp;y) &#123; switch(map-&gt;playerType[id]) &#123; case PLAYER_UNKNOWN: &#123; break; &#125; case PLAYER_AI: &#123; AI(map,id,x,y); break; &#125; case PLAYER_HUMAN: &#123; int ux=cursorx[id]; int uy=cursory[id]; map-&gt;p-&gt;setCursor(true,100); map-&gt;moveCursor(ux,uy); while(kbhit())getch(); while(true) &#123; int key=getch(); if(key==ARROW)key=key*256+getch(); int tx=ux,ty=uy; switch(key) &#123; case ESCAPE: &#123; closeKeyBoard(); exit(0); break; &#125; case'P': case'p': &#123; x=y=-1; map-&gt;p-&gt;setCursor(false); return; &#125; case' ': case'\n': &#123; x=ux; y=uy; map-&gt;p-&gt;setCursor(false); cursorx[id]=x; cursory[id]=y; return; &#125; case 256*ARROW+UP: case'W': case'w': &#123; tx--; break; &#125; case 256*ARROW+LEFT: case'A': case'a': &#123; ty--; break; &#125; case 256*ARROW+DOWN: case'S': case's': &#123; tx++; break; &#125; case 256*ARROW+RIGHT: case'D': case'd': &#123; ty++; break; &#125; case'R': case'r': &#123; tx=map-&gt;palacesx[id]; ty=map-&gt;palacesy[id]; break; &#125; case'G': case'g': &#123; map-&gt;alive[id]=false; map-&gt;p-&gt;setCursor(false); cursorx[id]=-1; cursory[id]=-1; return; &#125; &#125; if((tx!=ux||ty!=uy)&amp;&amp;map-&gt;inBound(tx,ty)) &#123; ux=tx; uy=ty; map-&gt;moveCursor(ux,uy); &#125; &#125; map-&gt;p-&gt;setCursor(false); break; &#125; &#125;&#125;char title[200];int main() &#123; initKeyBoard(); sprintf(title,"原子战役%s (加载中……)",GAME_VERSION); setTitle(title); Printer p; Map map(MAP_SIZE); map.p=&amp;p; int PLAYERS=PEOPLE_NUMBER; int HUMAN_PLAYERS=HUMAN_NUMBER; srand(time(NULL)); const int MAPS=7; MAP_STYLE_TYPE Maps[MAPS]=&#123;MAP_STYLE_ARENA,MAP_STYLE_RIVER,MAP_STYLE_HILL,MAP_STYLE_ISLAND,MAP_STYLE_RING,MAP_STYLE_BOB,MAP_STYLE_CLEAN&#125;; //分别为 中抢塔、过河、山地、中小塔、中大塔、没人小塔 int NUMBER=rand()%MAPS; if(MAP_SIZE&lt;=19) while(NUMBER==4) NUMBER=rand()%MAPS; if(MAP_SIZE&lt;=9) while(NUMBER==1||NUMBER==3||NUMBER==4||NUMBER==5) NUMBER=rand()%MAPS; NUMBER=2; map.buildMap(Maps[NUMBER],PLAYERS); map.p-&gt;setCursor(false); for(int i=0; i&lt;PLAYERS; i++) &#123; map.playerType[i]=i&lt;HUMAN_PLAYERS?PLAYER_HUMAN:PLAYER_AI; &#125; map.speed=SPEED_NONE; for(int i=0; i&lt;PLAYERS; i++) &#123; if(map.playerType[i]==PLAYER_HUMAN) &#123; cursorx[i]=map.palacesx[i]; cursory[i]=map.palacesy[i]; map.playerNames[i]=" 人类 "; &#125; else &#123; const double AILVS[]= &#123;0.0,0.3,0.3,0.5,0.5,0.5,0.9,0.9,0.9,0.95,0.95,1.0&#125;; AILV[i]=AILVS[rand()%(sizeof(AILVS)/sizeof(double))];//削弱AI难度 const char*name; if(AILV[i]&lt;=0.050)name="菜鸡AI"; else if(AILV[i]&lt;=0.400)name="蒟蒻AI"; else if(AILV[i]&lt;=0.600)name="萌新AI"; else if(AILV[i]&lt;=0.900)name="普通AI"; else if(AILV[i]&lt;=0.950)name="高手AI"; else if(AILV[i]&lt;=1.000)name="精英AI"; else name="神-ZRQ"; map.playerNames[i]=name; &#125; &#125; for(int i=1;; i++) &#123; map.resetEvent(); map.towersProduce(-1); map.progress(); for(int j=0; j&lt;PLAYERS; j++) &#123; if(map.alive[j]) &#123; if(!(map.speed&amp;SPEED_NOROUNDPRINT)) &#123; sprintf(title,TITLE_FORMAT,GAME_VERSION,i,map.playerNames[j]); setTitle(title); &#125; map.resetEvent(); map.towersProduce(j); map.progress(); int x,y; if(!(map.speed&amp;SPEED_NOROUNDPRINT))map.print(); decide(&amp;map,j,x,y); map.resetEvent(); if(map.choiceVaild(x,y,j))map.sendAtoms(x,y,-1,0,j,1); map.progress(); &#125; &#125; &#125; closeKeyBoard(); return 0;&#125;]]></content>
      <tags>
        <tag>娱乐</tag>
        <tag>c++小游戏</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[windows.h库小结]]></title>
    <url>%2F2019%2F10%2F05%2Fwindows%2F</url>
    <content type="text"><![CDATA[这里讲述了一些关于windows.h库的内容。 控制鼠标控制鼠标移动1::SetCursorPos(x,y); //让鼠标移动到(x,y)点。 控制鼠标点击12mouse_event(MOUSEEVENTF_LEFTDOWN,0,0,0,0); //鼠标按下mouse_event(MOUSEEVENTF_LEFTUP,0,0,0,0); //鼠标松开 控制键盘12keybd_event(x,0,0,0); //按下这个键keybd_event(x,0,KEYEVENTF_KEYUP,0); //松开这个键 键位表 检测1#define KEY_DOWN(VK_NONAME) ((GetAsyncKeyState(VK_NONAME)&amp;0x8000)?1:0) 检测鼠标123KEY_DOWN(VK_LBUTTON) //左键KEY_DOWN(VK_RBUTTON) //右键KEY_DOWN(VK_MBUTTON) //中键 检测键盘1KEY_DOWN(x) //是否按下这个键 键位表 控制光标位置12345678inline void print(int x,int y,char c)&#123; HANDLE hOut;COORD pos; hOut=GetStdHandle(STD_OUTPUT_HANDLE); pos.X=y;pos.Y=x; SetConsoleCursorPosition(hOut,pos); printf("%c",c);&#125; 在(x,y)这个位置输出一个字符c 使光标消失123456789inline void dis_mouse()&#123; ShowCursor(false); HANDLE hOut = GetStdHandle(STD_OUTPUT_HANDLE); CONSOLE_CURSOR_INFO cci; GetConsoleCursorInfo(hOut,&amp;cci); cci.bVisible=false; SetConsoleCursorInfo(hOut,&amp;cci);&#125; 控制台大小设定123456inline void set_windows(int x1,int y1,int x2,int y2)&#123; HANDLE hOut=GetStdHandle(STD_OUTPUT_HANDLE);SMALL_RECT rc; rc.Left=x1,rc.Top=y1,rc.Right=x2,rc.Bottom=y2; SetConsoleWindowInfo(hOut, TRUE, &amp;rc);&#125; 改变颜色1void color(int a) &#123;SetConsoleTextAttribute(GetStdHandle(STD_OUTPUT_HANDLE),a);&#125; 颜色表]]></content>
      <tags>
        <tag>电脑</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数学题2]]></title>
    <url>%2F2019%2F10%2F05%2Fmath1%2F</url>
    <content type="text"><![CDATA[这里有一道毒瘤数学题 题目已知：$BD$与$EC$交于$O$，$AE=AD$，$BO=CO$求证：$AB=AC$ 知识 初中平面几何 三角形内大角对大边 正弦函数的单调性 正弦定理P.S.$\color{red}{\texttt{我的辅助线就不用虚线了}}$$\color{red}\texttt{不要小看这道题！！！}$ 题解证（用反证法）：连接$ED$假设$\angle OED&gt;\angle ODE$$\because \angle OED&gt;\angle ODE$$\therefore OD&gt;OE\Rightarrow -OE&gt;-OD\qquad\qquad(1)$$\because AE=AD$$\therefore \angle AED=\angle ADE$$\therefore \angle BED=\angle CDE$$\because \angle OED&gt;\angle ODE$$\therefore \angle C&lt;\angle B$$\because \angle C,\angle B]]></content>
      <tags>
        <tag>平面几何</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数学题1]]></title>
    <url>%2F2019%2F10%2F05%2Fmath2%2F</url>
    <content type="text"><![CDATA[这里有一道毒瘤数学题 题目已知：$D$是$BC$的中点，$\angle ADB=60^\circ$，$2\angle ACB=\angle ABC$求证：$\angle CAB=90^\circ$ 知识 初中平面几何P.S.$\color{red}{\texttt{我的辅助线就不用虚线了}}$$\color{red}{\texttt{不要小看这道题！！！}}$ 题解证：把$\triangle ADB$沿$AD$对折得到$\triangle AED$，连接$EC，ED$设$\angle ACB=\alpha$，则$\angle ABC=2\alpha$$\because \angle ADB=90^\circ,\triangle AED \cong \triangle ABD$$\therefore \angle ADE=\angle ADB=60^\circ$$\therefore \angle EDC=180^\circ-\angle ADB-\angle ADE=60^\circ$$\because DE=DB，D$是$BC$的中点$\therefore ED=DB=DC$$\therefore \triangle ECD$是正$\triangle$$\therefore \angle DCE=\angle DEC=60^\circ$$\therefore \angle ECA=60-\alpha$$\because \triangle AED \cong \triangle ABD$$\therefore \angle AED=\angle ABD=2\alpha$$\therefore \angle EAC=180^\circ-\angle ECA-\angle CED-\angle DEA$$\qquad\qquad\;=180^\circ-(60^\circ-\alpha)-60^\circ-2\alpha=60^\circ-\alpha$$\therefore \angle ECA=\angle EAC$$\therefore EC=EA$$\therefore AB=EA=EC=CD=DB$$\therefore \triangle ADB$是正$\triangle$$\therefore \angle ABD=60^\circ$$\because \angle ABD=2\alpha$$\therefore \alpha=30^\circ$$\therefore \alpha=180^\circ-\angle ACB-\angle ABC$$\qquad=180^\circ-30^\circ-60^\circ=90^\circ$]]></content>
      <tags>
        <tag>平面几何</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[离散化]]></title>
    <url>%2F2019%2F10%2F05%2Flisnahua%2F</url>
    <content type="text"><![CDATA[直接上代码点击显/隐代码 1234567891011121314151617181920212223242526272829303132333435363738#include&lt;fstream&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;struct shu&#123; int xuhao,shuzi,ans;&#125;;int n;shu a[100005];bool cmp1(shu a,shu b)&#123; return a.shuzi&lt;b.shuzi;&#125;bool cmp2(shu a,shu b)&#123; return a.xuhao&lt;b.xuhao;&#125;int main()&#123; cin&gt;&gt;n; for(int i=1;i&lt;=n;i++) &#123; cin&gt;&gt;a[i].shuzi; a[i].xuhao=i; &#125; sort(a+1,a+n+1,cmp1); a[1].ans=1; for(int i=2;i&lt;=n;i++) &#123; if(a[i].shuzi==a[i-1].shuzi) a[i].ans=a[i-1].ans; else a[i].ans=i; &#125; sort(a+1,a+n+1,cmp2); for(int i=1;i&lt;=n;i++) cout&lt;&lt;a[i].ans&lt;&lt;' '; cout&lt;&lt;endl; return 0;&#125;]]></content>
      <tags>
        <tag>离散化</tag>
        <tag>模板</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[OI的知识]]></title>
    <url>%2F2019%2F10%2F05%2Fstudy%2F</url>
    <content type="text"><![CDATA[function doDecrypt (pwd, onError) { console.log('in doDecrypt'); const txt = document.getElementById('enc_content').innerHTML; let plantext; try { const bytes = CryptoJS.AES.decrypt(txt, pwd); var plaintext = bytes.toString(CryptoJS.enc.Utf8); } catch(err) { if(onError) { onError(err); } return; } document.getElementById('enc_content').innerHTML = plaintext; document.getElementById('enc_content').style.display = 'block'; document.getElementById('enc_passwd').style.display = 'none'; if(typeof MathJax !== 'undefined') { MathJax.Hub.Queue( ['resetEquationNumbers', MathJax.InputJax.TeX], ['PreProcess', MathJax.Hub], ['Reprocess', MathJax.Hub] ); } } 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 var onError = function(error) { document.getElementById("enc_error").innerHTML = "password error!" }; function decrypt() { var passwd = document.getElementById("enc_pwd_input").value; console.log(passwd); doDecrypt(passwd, onError); }]]></content>
      <tags>
        <tag>学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[高精度模板]]></title>
    <url>%2F2019%2F10%2F05%2Finteger%2F</url>
    <content type="text"><![CDATA[直接上代码点击显/隐代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186#include&lt;bits/stdc++.h&gt;using namespace std;struct number&#123; int size,num[1005]; number() &#123; memset(num,0,sizeof(num)); &#125; inline void read() &#123; char c[1005]; scanf("%s",c+1); size=strlen(c+1); for(int i=1;i&lt;=size;i++) num[i]=c[size-i+1]-'0'; &#125; inline void init(int a) &#123; size=0; while(a) &#123; size++; num[size]=a%10; a/=10; &#125; &#125; inline void write() &#123; for(int i=size;i&gt;=1;i--) printf("%d",num[i]); printf("\n"); &#125; inline bool operator!=(const number &amp;a) const &#123; if(size!=a.size) return true; for(int i=size;i&gt;=1;i--) if(num[i]!=a.num[i]) return true; return false; &#125; inline bool operator==(const number &amp;a) const &#123; if(*this!=a) return false; return true; &#125; inline bool operator&lt;(const number &amp;a) const &#123; if(size!=a.size) return size&lt;a.size; for(int i=size;i&gt;=1;i--) if(num[i]!=a.num[i]) return num[i]&lt;a.num[i]; return false; &#125; inline bool operator&lt;=(const number &amp;a) const &#123; if(*this&lt;a||*this==a) return true; return false; &#125; inline bool operator&gt;(const number &amp;a) const &#123; if(*this&lt;=a) return false; return true; &#125; inline bool operator&gt;=(const number &amp;a) const &#123; if(*this&lt;a) return false; return true; &#125; inline number operator+(const number &amp;a) const &#123; number ans; int t=0; ans.size=max(size,a.size); for(int i=1;i&lt;=ans.size;i++) &#123; ans.num[i]=num[i]+a.num[i]+t; t=ans.num[i]/10; ans.num[i]%=10; &#125; if(t) &#123; ans.size++; ans.num[ans.size]+=t; &#125; while(ans.num[ans.size]&gt;=10) &#123; ans.num[ans.size+1]+=ans.num[ans.size]/10; ans.num[ans.size]%=10; ans.size++; &#125; return ans; &#125; inline number operator-(const number &amp;a) const &#123; number ans; int t=0; ans.size=max(size,a.size); for(int i=1;i&lt;=ans.size;i++) &#123; ans.num[i]=num[i]-a.num[i]+t; int x=(ans.num[i]+10)%10; t=(ans.num[i]-x)/10; ans.num[i]=x; &#125; while(!ans.num[ans.size]&amp;&amp;ans.size&gt;1) ans.size--; return ans; &#125; inline number operator*(const number &amp;a) const &#123; number ans; ans.size=size+a.size; for(int i=1;i&lt;=size;i++) for(int j=1;j&lt;=a.size;j++) ans.num[i+j-1]+=num[i]*a.num[j]; for(int i=1;i&lt;ans.size;i++) &#123; ans.num[i+1]+=ans.num[i]/10; ans.num[i]%=10; &#125; while(!ans.num[ans.size]&amp;&amp;ans.size&gt;1) ans.size--; return ans; &#125; inline number times(int b) &#123; number ans; ans.size=size; for(int i=1;i&lt;=ans.size;i++) ans.num[i]=num[i]*b; for(int i=1;i&lt;ans.size;i++) &#123; ans.num[i+1]+=ans.num[i]/10; ans.num[i]%=10; &#125; while(ans.num[ans.size]&gt;=10&amp;&amp;ans.size&gt;1) &#123; ans.num[ans.size+1]+=ans.num[ans.size]/10; ans.num[ans.size]%=10; ans.size++; &#125; while(!ans.num[ans.size]&amp;&amp;ans.size&gt;1) ans.size--; return ans; &#125; inline number divition(int x) &#123; if(!x) return *this; number ans; int t=0; ans.size=size; for(int i=ans.size;i&gt;=1;i--) &#123; t=t*10+num[i]; ans.num[i]=t/x; t%=x; &#125; while(!ans.num[ans.size]&amp;&amp;ans.size&gt;1) ans.size--; return ans; &#125; inline number pow(int x) &#123; number ans,res=*this; ans.size=1; ans.num[ans.size]=1; for(int i=x;i;i&gt;&gt;=1,res=res*res) if(i&amp;1) ans=ans*res; return ans; &#125; inline number sqrt(int q) &#123; number l,r=*this,mid,x,t,one; one.size=1; one.num[1]=0; l=one; one.num[1]=1; while(l&lt;=r) &#123; x=l+r; x=x.divition(2); t=x.pow(q); if(t==*this) return x; if(t&lt;*this) l=x+one; else r=x-one; &#125; return r; &#125;&#125;;int main()&#123;&#125;]]></content>
      <tags>
        <tag>模板</tag>
        <tag>高精</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[fhq_tree模板]]></title>
    <url>%2F2019%2F10%2F05%2Ffhq-tree%2F</url>
    <content type="text"><![CDATA[直接上代码点击显/隐代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586#include&lt;bits/stdc++.h&gt;using namespace std;struct tree&#123; struct node &#123; int val,siz,lson,rson; node(int v=0,int s=1,int l=0,int r=0):val(v),siz(s),lson(l),rson(r) &#123;&#125; &#125;t[500005]; tree() &#123;root=1,srand(time(0)),t[0].siz=0;&#125; int root; inline char Rand(int a,int b) &#123;return rand()%(a+b)&lt;a;&#125; inline void update(int x) &#123;t[x].siz=t[t[x].lson].siz+t[t[x].rson].siz+1;&#125; inline int new_node(int x) &#123; static int tot=0; t[++tot]=node(x,1,0,0); return tot; &#125; inline int lfind(int x) &#123;return t[x].lson?lfind(t[x].lson):t[x].val;&#125; inline int rfind(int x) &#123;return t[x].rson?rfind(t[x].rson):t[x].val;&#125; inline void sbyval(int x,int k,int &amp;a,int &amp;b) &#123; if(x==0) a=b=0; else if(t[x].val&lt;=k) a=x,sbyval(t[x].rson,k,t[a].rson,b),update(a); else b=x,sbyval(t[x].lson,k,a,t[b].lson),update(b); &#125; inline void sbysiz(int x,int k,int &amp;a,int &amp;b) &#123; if(x==0) a=b=0; else if(k&lt;=t[t[x].lson].siz) b=x,sbysiz(t[x].lson,k,a,t[x].lson),update(x); else a=x,sbysiz(t[x].rson,k-t[t[x].lson].siz-1,t[x].rson,b),update(x); &#125; inline int merge(int x,int y) &#123; if(x==0||y==0) return x+y; if(x==y) return x; if(Rand(t[x].siz,t[y].siz)) return t[x].rson=merge(t[x].rson,y),update(x),x; return t[y].lson=merge(x,t[y].lson),update(y),y; &#125; inline void ins(int k) &#123; int r1=root,r2=root; sbyval(root,k,r1,r2); root=merge(merge(r1,new_node(k)),r2); &#125; inline void del(int k) &#123; int r1=root,r2=root,r3=root,r=root; sbyval(root,k,r,r3); sbyval(r,k-1,r1,r2); r2=merge(t[r2].lson,t[r2].rson); root=merge(merge(r1,r2),r3); &#125; inline int rank(int k) &#123; int r1=root,r2=root,ans; sbyval(root,k-1,r1,r2); ans=t[r1].siz,root=merge(r1,r2); return ans+1; &#125; inline int data(int k) &#123; int r1=root,r2=root,ans; sbysiz(root,k-1,r1,r2); ans=lfind(r2),root=merge(r1,r2); return ans; &#125; inline int last(int k) &#123; int r1=root,r2=root,ans; sbyval(root,k-1,r1,r2); ans=rfind(r1),root=merge(r1,r2); return ans; &#125; inline int next(int k) &#123; int r1=root,r2=root,ans; sbyval(root,k,r1,r2); ans=lfind(r2),root=merge(r1,r2); return ans; &#125;&#125;;int main()&#123;&#125;]]></content>
      <tags>
        <tag>模板</tag>
        <tag>平衡树</tag>
        <tag>fhq_tree</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[光速乘]]></title>
    <url>%2F2019%2F10%2F05%2Ftimes%2F</url>
    <content type="text"><![CDATA[直接上代码点击显/隐代码 12345678typedef long long ll;typedef long double lb;const lb dx=1e-8;inline ll multi(ll x,ll y,ll mod)&#123; ll tmp=(x*y-(ll)((lb)x/mod*y+dx)*mod); return tmp&lt;0?tmp+mod:tmp;&#125;]]></content>
      <tags>
        <tag>模板</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[分数模板]]></title>
    <url>%2F2019%2F10%2F05%2Ffrac%2F</url>
    <content type="text"><![CDATA[直接上代码点击显/隐代码 1234567891011121314151617181920212223#include&lt;bits/stdc++.h&gt;using namespace std;inline int gcd(int a,int b) &#123;return b==0||a==0?a+b:gcd(b,a%b);&#125;struct frac&#123; int x,y; inline frac yue() &#123;return (frac)&#123;x/gcd(x,y),y/gcd(x,y)&#125;;&#125; inline frac dao() &#123;return (frac)&#123;y,x&#125;;&#125; inline void read() &#123;scanf("%d%d",&amp;x,&amp;y);&#125; inline void write() &#123;printf("%d/%d\n",x,y);&#125; inline bool operator&lt;(frac a) const &#123;return x*a.y&lt;y*a.x;&#125; inline bool operator==(frac a) const &#123;return x*a.y==y*a.x;&#125; inline bool operator&lt;=(frac a) const &#123;return *this&lt;a||*this==a;&#125; inline bool operator&gt;(frac a) const &#123;return !(*this&lt;=a);&#125; inline bool operator&gt;=(frac a) const &#123;return !(*this&lt;a);&#125; inline bool operator!=(frac a) const &#123;return !(*this==a);&#125; inline frac operator+(frac a) const &#123;return (frac)&#123;x*a.y+y*a.x,y*a.y&#125;.yue();&#125; inline frac operator-(frac a) const &#123;return (frac)&#123;x*a.y-y*a.x,y*a.y&#125;.yue();&#125; inline frac operator*(frac a) const &#123;return (frac)&#123;x*a.x,y*a.y&#125;.yue();&#125; inline frac operator/(frac a) const &#123;return *this*a.dao();&#125;&#125;;int main()&#123;&#125;]]></content>
      <tags>
        <tag>模板</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[娱乐相关]]></title>
    <url>%2F2019%2F10%2F05%2Fhappy%2F</url>
    <content type="text"><![CDATA[$\color{red}{\texttt{转载请注明出处}}$ 一些有趣的东西天空有多高宇宙有多大历史上的$\texttt{3.14}$什么是c++百度-黑洞百度-翻转百度-跳动密码1密码2彩虹1彩虹2彩虹3神奇画图再见了陈哲模拟三体滑稽滑稽天气预报在线虚拟机黑客b站专区采访kkkOI AK 杀喜之郎派大星教你接电话1派大星教你接电话2派大星教你接电话3派大星教你接电话4 一些神奇的游戏IO游戏$\texttt{2048}$（正版）$\texttt{2048}$（洛谷版）$\texttt{2048}$（$\texttt{2}$）$\texttt{2048}$（$\texttt{3}$）$\texttt{2048}$（假$\texttt{1}$）$\texttt{2048}$（假$\texttt{2}$）splaysplay2洛谷的splay小型splay信任的进化名字竞技场超级玛丽奥流浪日记小黑屋IO游戏点击工匠$\texttt{arras.io}$$\texttt{diep.io}$$\texttt{wings.io}$$\texttt{surviv.io}$细胞分裂脑洞大开魔法师的对决猫国建设者一只鸟传说游戏在线下棋球球大作战膜拜Siyuan扫雷 客服是如何被调戏的材料1 c++小游戏扫雷推箱子贪吃蛇俄罗斯方块帝国原子战役$\texttt{UNO}$（自己打的）$\texttt{something else1}$$\texttt{2048}$ 西江月 证明即得易见平凡，仿照上例显然。留作习题答案略，读者自证不难。反之亦然同理，推证自然成立。略去过程QED，由上可知证毕。 江城子 挂科一夜复习两茫茫。看一句，忘三行。路遇友人，脸色皆凄凉。视死如归入考场，心里慌，手中忙。考完之后心凉凉。左右曰，今必亡。查成绩，众人皆过我独亡。再顾昔时左右人，这一群，装逼朗。 $\texttt{To chase a girl needs time and money.}$$\texttt{So we can say：Girl=}\texttt{Time}\times \texttt{Money}$$\texttt{As we all know,”time is money”.}$$\texttt{So：Girl=Money}^\texttt{2}$$\texttt{What’s more,”money is the}\;\text{root}\;\texttt{of evil”.}$$\texttt{Thus：Girl=(}\sqrt{\texttt{Evil}}\texttt{)}^\texttt{2}$$\texttt{so：Girl=Evil}$ 这个手刹不太灵泰尼号坦克哈利波特与凤凰传奇妇产科联盟变形钢筋4家乐福海盗魂断蓝翔忠犬洪七公梁山伯与朱丽叶大侦探福尔马斯拯救大兵张嘎唐伯虎点蚊香决战杀马特钢筋侠午夜闹铃 这里是洛谷 现在面向全国的$\texttt{OIer}$们做最后播报在过去的三十六小时里 $\texttt{OIer}$们经历了有史以来最大的刷题危机在全球各国一百五十万教练的拼搏与催促下$\texttt{71}$%的初中$\texttt{OIer}$和100%高中$\texttt{OIer}$开始全功率刷题但遗憾的是目前的$\texttt{OI}$题量 已经超过全部$\texttt{OIer}$的总做题功率 $\texttt{OIer}$错失了最后的做完题目机会为了$\texttt{OIer}$文明之延续$\texttt{kkksc03}$将启动火种计划洛谷储藏了三十万题目和一亿本$\texttt{OIer}$书 储存着全球已知的神犇名字 并设有全部$\texttt{OIer}$文明的数字资料库 以确保在新的$\texttt{OJ}$网站重建完整的OI文明你们都是洛谷的英雄 我们谨记于心 以你们为荣 我们将肩负着你们全部的希望 刷掉所有的黑题 这里是领航员空间站 现在面向全球做最后播报在过去的三十六小时里 人类经历了有史以来最大的生存危机在全球各国一百五十万救援人员的拼搏和牺牲下$\texttt{71}$%的推进发动机和$\texttt{100}$%转向发动机被全功率重启但遗憾的是目前的木星引力 已经超过全部发动机的总输出功率 地球错失了最后的逃逸机会为了人类文明之延续 莫斯将启动火种计划领航员空间站冷藏了三十万人类的受精卵和一亿颗基础农作物的种子 储存着全球已知的动植物$\texttt{DNA}$图谱 并设有全部人类文明的数字资料库 以确保在新的移民星球重建完整的人类文明你们都是地球的英雄 我们谨记于心 以你们为荣 我们将肩负着你们全部的希望 飞向两千五百年后的新家园 在过去的三十六小时里, 中学生经历了有史以来最大的生存危机。在全国各省一百五十多万教师的不懈催促下,$\texttt{71}$%的初中生和$\texttt{100}$%的高中生被全功率重启。但遗憾的是,目前的寒假作业量,已经超过了全部学生的总输出功率。中学生,失去了最后的写完作业的机会。在最后的这七天里, 大家回家吧, 抱抱自己的父母，尽情享受剩下的日子。播报完毕。 哪儿来的七天啊!不到$\texttt{18}$小时高三狗就会被学校全部剥离！哪儿来的七天！ 我们还有最后一个机会,作业的成分百分之$\texttt{90}$都是纸, 在暴露于地球大气的情况下,点燃只需要一根火柴！爆燃产生$\texttt{2333}$马赫以上的冲击波产生的动能足以推开开学的危机来吧!我们点燃作业! 【备选】（”学校,就是一座大房子,里面90%都是钢筋混凝土结构。”“钢筋混凝土是什么啊?””钢筋混凝土,就是爸爸做定向爆破的楼。”…”我想到了! 炸掉学校! 炸掉学校! 我们还有一个机会!”）“本计划已在12小时前由北京市第三体校学生团队提出，经计算，该计划成功的可能性为$\texttt{0}%$”“这里是教导处我们无法接受您的要求让已经放弃作业跑路的中学生重新返回教室放弃和亲人最后见面的机会去做一堆写不完的作业”“无论最后结果将学生作业弄成什么样，我们选择不收。”“七天是写不了作业的！”“那我们还写什么？” （车子掉头） 流浪$\texttt{NOIP}$计划，共分为$\texttt{5}$步： 第一步，各大支持信竞初高中停止上课，为$\texttt{NOIP}$的远行做好准备；第二步，加大交通工具功率，在各个省内完成集结，集体脱离所在省；第三步，在沿途省市继续加速，冲向帝都；第四步，在中途完成洛谷月赛，并调整方向准备减速；第五步，进入帝都，给$\texttt{jyb}$添上一根火柴。 大家知道，jyb一半以上的决策都不过大脑。现在各方$\texttt{NOIP}$的怒气已经充分混合，一根火柴就能把它引燃，所有的文件不攻自破，产生的影响力足以震慑各大高层。 我们还有最后的希望。 我们点燃jyb！by 《流浪$\texttt{coding}$》 一群伟大的科学家死后在天堂里玩藏猫猫，轮到爱因斯坦抓人，他数到100睁开眼睛，看到所有人都藏起来了，只见伏特趴在不远处。爱因斯坦走过去说：“伏特，我抓住你了。”伏特说：“不，你没有抓到我。”爱因斯坦：“你不是伏特你是谁？”伏特：“你看我身下是什么？”爱因斯坦低头看到在伏特身下，居然是安培！伏特：“我身下是安培，我俩就是伏特/安培，所以你抓住的不是我，你抓住的是….”……欧姆！爱因斯坦反应迅速，于是改口喊，“欧姆，我抓住你了！”说时迟那时快，伏特和安培一个鱼跃站了起来，但是仍然紧紧抱在一起，爱因斯坦大惑～他俩不紧不慢地说，现在，我们不再是欧姆，而是伏特×安培， 变成瓦特了～爱因斯坦觉得有道理，于是喊，那我终于抓到你了，瓦特！这时候，安培慢慢悠悠地说：“你看我俩这样抱着已经有好几秒了，所以，我们不再是瓦特，而是瓦特×秒，我们现在是焦耳啦～”爱因斯坦被说的哑口无言，于是默默地转过身，这时，他看到牛顿站在不远处，爱因斯坦于是跑过去说：“牛顿，我抓住你了。”牛顿：“不，你没有抓到牛顿。”爱因斯坦：“你不是牛顿你是谁？”牛顿：“你看我脚下是什么？”爱因斯坦低头看到牛顿站在一块长宽都是一米的正方形的地板砖上，不解。牛顿：“我脚下这是一平方米的方块，我站在上面就是牛顿/平方米，所以你抓住的不是牛顿，你抓住的是帕斯卡”爱因斯坦倍受挫折，终于忍无可忍地爆发了，于是飞起一脚，踹在牛顿身上，把牛顿踹出了那块一平米的地板砖，然后吼到：“说！你还敢说你是帕斯卡？？”牛顿慢慢地从地上爬起来，说：“不，我已经不是帕斯卡了，你刚刚让我牛顿移动了一米的距离，所以，我现在也是焦耳了” 我们学校食堂的汤被称为斐波那契汤。因为今天的汤是由昨天的汤与前天的混合而成的。 老婆给当程序员的老公打电话：“下班顺路买一斤包子带回来，如果看到卖西瓜的，就买一个。”当晚，程序员老公手捧一个包子进了家门……老婆怒道：“你怎么就买了一个包子？！”老公答曰：“因为看到了卖西瓜的。” C语言和C++最大的区别是，C容易擦枪走火让你的膝盖中箭。用C++显然不会这样，但一旦走火，就炸掉你整条腿。 开学后的某一天，老湿走进课堂对学生们说，今天，我们开始我们的第一个c++程序，叫hell，world……讲到高潮，某同学说，c++真tm简单吧。老湿巨汗。下课后，老湿找到那个同学，说，你今天的作业时在屏幕上显示出10000个hello，world。据说，那个晚上那同学都在ctrl c + ctrl v 客户被绑，蒙眼，惊问：“想干什么？” 对方不语，鞭笞之，客户求饶：“别打，要钱？” 又一鞭，“十万够不？” 又一鞭，“一百万？” 又一鞭。 客户崩溃：“你们TMD到底要啥？” “要什么？我帮你做项目，写代码的时候也很想知道你TMD到底想要啥！” 记者问一位大爷说：老大爷，您保持年轻的秘诀是什么？ 大爷说：白天上班，夜晚加班，节假日值班，一天五包烟，天天吃泡面。 记者问：老大爷，您是干什么工作的？ 大爷说：我是程序员！ 记者：啊？？大爷您今年高寿？ 大爷：老子今年35！ 如果一个足球界的人“猝死”了，会被怀疑和赌球有关； 如果一个官员“猝死”了，会被怀疑和贪腐有关； 如果一个农民”猝死”了，会被怀疑和拆迁有关； 而如果一个程序员猝死了，那他真的猝死了。 对于各种凌乱的电脑问题，手机问题，其他行业的人，以为程序员们什么都会。 程序员中，女程序员以为男程序员什么都会。 男程序员中，一般程序员以为技术好的程序员什么都会。 技术好的程序员，每次都在网上苦苦找答案。 从前，有一个程序猿，他得到了一盏神灯。灯神答应实现他一个愿望。然后他向神灯许愿，希望在有生之年能写一个好项目。 后来…后来…他得到了永生。 今天在公司听到一句惨绝人寰骂人的话 “你TM就是一个没有对象的野指针!” 算法是什么？ 算法就是当程序员不想解释他做了什么的时候最常用到的一个词。 有人说，女程序员再淑女，一旦编程就会暴露自己的身份，习惯性的把前额的头发往上捋，露出大大的额头。 因为CPU高速运作时需要良好的散热 一氧化二氢的危险包括： 又叫做“氢氧基酸”，是酸雨的主要成分； 对泥土流失有促进作用； 对温室效应有推动作用； 它是腐蚀的成因； 过多的摄取可能导致各种不适； 皮肤与其固体形式长时间的接触会导致严重的组织损伤； 吸入该物质容易引发窒息； 发生事故时吸入也有可能致命； 处在气体状态时，它能引起严重灼伤； 在不可救治的癌症病人肿瘤中已经发现该物质； 人类只要一接触一氧化二氢就会发生不可逆转的上瘾，对此物质上瘾的人离开它168小时便会死亡； 全球每年因一氧化二氢死亡者超过37万； 是大多数有毒溶液的溶剂； 尽管有如此的危险，一氧化二氢常常被用于： 各式各样的残忍的动物研究； 美国海军有秘密的一氧化二氢的传播网； 全世界的河流及湖泊都被一氧化二氢污染； 常常配合杀虫剂使用； 洗过以后，农产品仍然被这种物质污染； 几乎所有食物都被其污染； 地球上空气全部被其污染，含量高达0.01%-0.03%，某些地区高达1%； 在一些“垃圾食品”和其它食品中的添加剂； 已知的导致癌症的物质的一部分； 然而，政府和众多企业仍然大量使用一氧化二氢，而不在乎其极其危险的特性。 班长说:走，我们去炸学校副班长说:这个主意不错化学课代表负责提取氢气物理课代表负责拼装氢弹数学课代表负责计算爆破面积地理课代表负责策划爆破地点信息课代表负责编写氢弹程序历史课代表负责记录光辉场面美术课代表负责描画壮观景致生物课代表负责事后生态环境政治课代表负责使用法律打官司语文课代表负责乱写文章推卸责任英语课代表到外国购买进口材料 为了证明蜘蛛的听觉在脚上，专家做了一个实验。先是把一直蜘蛛放在实验台上，然后冲蜘蛛大吼了一声，蜘蛛吓跑了！之后把这只蜘蛛又抓了回来，然后把蜘蛛的脚全部割掉，再冲蜘蛛大吼了一声，蜘蛛果然不动了！于是，专家发表论文，证明了蜘蛛的听觉在脚上。 为了证明这位专家脑子里全是屎，我们做了一个实验。先是把这位专家放在马桶上，专家会拉屎。之后吧这位专家脑子切了，再放在马桶上，专家果然不拉屎了。于是，我们发表论文，证明这位专家脑子里全是屎。 $\texttt{OI}$选手转篮球赛没前途的。你看看一个个整天就知道暴力。打篮球还不都被红牌判罚。 有一种$\texttt{OIer}$是$\texttt{for}$从$\texttt{1}$开始的，还有一种$\texttt{OIer}$是$\texttt{for}$从$\texttt{0}$开始的。我是第$\color{red}{\texttt{1}}$种。请问我$\texttt{for}$从多少开始？ $\texttt{OIer}$的本质是$\texttt{fAKe}$。我是$\color{red}{\texttt{真}}$的$\texttt{OIer}$.请问我到底是不是$\texttt{fAKer}$ 取少量学生放入试管，加入过量作业，生成学霸溶液和不溶于水的作业化学渣沉淀。过滤，在作业化学渣中加入浓论文的四氯化碳溶液和氢气，生成学渣化氢沉淀和一氢合论文作业溶液。过滤，在得到的学渣化氢中加入过量浓试卷的苯酚溶液，学渣迅速溶解且产生气泡，学霸则无明显现象。 $(-1)-1\times(4-5\times1^4)=0$$1^{(1-4-5^{14})}=1$$(-1)\times(1+(4+5)/(1-4))=2$$(-1)\times(1+(4-5\times1)\times4)=3$$(-1)-1\times(4-5-1\times4)=4$$(-1)-1\times(4-5-1-4)=5$$(-1)+14/(5+1-4)=6$$(-1)\times(1+(4-5-1)\times4)=7$$(-1)-1^4\times(5-14)=8$$(-1)+1\times(4+5+1^4)=9$$(-1)-1\times(4+5\times(1-4))=10$$(-1)-1\times(4-(5-1)\times4)=11$$(-1)+1\times(4-5+14)=12$$(-1)\times(1+(4-5)\times14)=13$$(-1)-1\times(4-5-14)=14$$(-1)-1\times(4-5\times1\times4)=15$$1-1\times(4-5-14)=16$$1-1\times(4-5\times1\times4)=17$$(-1)\times(1-4+5\times(1-4))=18$$(-1)-1\times(4-(5+1)\times4)=19$$(-1)-1\times(4-5\times(1+4))=20$$1-1\times(4-(5+1)\times4)=21$$(-1)\times(1-4-5-14)=22$$(-1)-(1-4)\times(5-1+4)=23$$1+1\times(4+5+14)=24$$1-(1-4)\times(5-1+4)=25$$(-1)-(1-4)\times(5+1\times4)=26$$(-1)+1-(4+5)\times(1-4)=27$$(-1)\times(1-4-5\times(1+4))=28$$(-1)-(1-4)\times(5+1+4)=29$$(-1)+1\times(45-14)=30$$(-1)-(1-4-5\times1)\times4=31$$1+1\times(45-14)=32$$(-1)\times(1-4\times5-14)=33$$(-11)+(4+5)\times(1+4)=34$$(-1)-1\times4\times(5-14)=35$$(-1)+1-4\times(5-14)=36$$1-1\times4\times(5-14)=37$$1\times(14+(5+1)\times4)=38$$(-1)\times(1-4\times(5+1+4))=39$$(-1)\times(1-45+1\times4)=40$$(-1)\times(1-45-1+4)=41$$(-1)-1\times(4-51+4)=42$$(-1)+1\times(45-1^4)=43$$(-1)-(1+4)\times(5-14)=44$$1+1\times(45-1^4)=45$$(-1)\times(1^4-51+4)=46$$(-1)\times(1-45+1-4)=47$$(-1)\times(1-45-1\times4)=48$$(-1)\times(1-45-1-4)=49$$(-1)-1\times(4-51-4)=50$$1+1\times(45+1+4)=51$$1-1\times(4-51-4)=52$$(-11)+4\times(5-1)\times4=53$$(-1)\times(1^4-51-4)=54$$(-1)+14\times(5-1^4)=55$$(-1)-(1-4)\times(5+14)=56$$1+14\times(5-1^4)=57$$(-1)\times(1-45-14)=58$$(-1)-1\times4\times5\times(1-4)=59$$1+1\times(45+14)=60$$1-1\times4\times5\times(1-4)=61$$(-1)-1+4\times(5-1)\times4=62$$(-1)-((1-4)\times5-1)\times4=63$$(-1)+1+4\times(5-1)\times4=64$$(-1)-1\times(4-5\times14)=65$$1\times(14\times5-1\times4)=66$$(-1)+(1+4\times(5-1))\times4=67$$(1+1)\times(4\times5+14)=68$$(-1)\times(1^4-5\times14)=69$$(-1)+1^4+5\times14=70$$(-1)-(1-4)\times(5+1)\times4=71$$((-1)-1)\times4\times(5-14)=72$$(-1)\times(1-4-5\times14)=73$$(-1)-1+4\times(5+14)=74$$(-1)-(1-4\times5\times1)\times4=75$$(-1)+1+4\times(5+14)=76$$1-(1-4\times5\times1)\times4=77$$(-1)-1+4\times5\times1\times4=78$$(-1)-(1-4\times5-1)\times4=79$$(-1)+1+4\times5\times1\times4=80$$1-(1-4\times5-1)\times4=81$$(-1)-1+(4\times5+1)\times4=82$$(-1)\times(1-(4\times5+1)\times4)=83$$(-1)+1+(4\times5+1)\times4=84$$1+14\times(5+1^4)=85$$((-1)-1)\times(4-51+4)=86$$(-1)+(1+4\times5+1)\times4=87$$(1+1)\times(45-1^4)=88$$1+(1+4\times5+1)\times4=89$$(-114)+51\times4=90$$(-1)-(1-4\times(5+1))\times4=91$$(1+1)\times(45+1^4)=92$$1-(1-4\times(5+1))\times4=93$$(-1)+(1+4)\times(5+14)=94$$(-1)\times(1-4\times(5+1)\times4)=95$$1+(1+4)\times(5+14)=96$$1+1\times4\times(5+1)\times4=97$$(-1)-1+4\times5\times(1+4)=98$$(-1)\times(1-4\times5\times(1+4))=99$$(-1)+1+4\times5\times(1+4)=100$ 考试不作弊，放你他妈屁。考试不翻书，简直是头猪。作弊不要慌，逮到就要装。生是中国人，死是中国魂。要我学洋文，死都不可能。抢饭不积极，智商有问题。上课不放屁，肠道有问题。英语不及格，说明我爱国。语文不及格，恋爱没资格。物理不及格，电死不负责。化学不及格，硫酸也喝得。政治不及格，老师没道德。信息不及格，网吧要打折。数学不及格，突出我性格。历史不及格，社会要改革。全科不及格，老妈动真格。 玻璃是用沙子做的，那就是$\color{red}{\text{沙雕}}$…… 你是否还记得，昔日的辉煌？想当年，你仅靠一壶水，竟奇迹般地穿越了整个沙漠。是什么，支持着你？是它，—泰山。你知道，只有登上泰山，五岳之尊，你才能蜕变，成为一个真正的勇士。便是这黑暗中的一丝希望，便能成为你无穷的动力之源。斩杀怪蜥，击退盗贼，只有你知道，这些力量来自何方。最后的最后，你来到了这里。你站在山下，仰望这座巍峨高耸的山脉，从容地走上前去，写下四个大字：$\color{red}\text$ 大人们忙着去$\texttt{SB}$（上班）;我呢，就来上网看看又有什么新消息在$\texttt{SB}$（散播）;晚上,点菜的时候我说$\texttt{SB}$（随便）;吃饱了到大街上$\texttt{SB}$（散步）;回来手里就抓着$\texttt{SB}$（鼠标）;有心情还去博客里写写$\texttt{SB}$（随笔）;人，整天都在$\texttt{SB}$!有幸碰到两美国美妞聊天，以为自己英文过关，但只听清一句话就是$\texttt{SB}$（somebody = sb.）;人活着可真$\texttt{SB}$（失败）啊……..那年我$\texttt{SB}$（十八），到部队当$\texttt{SB}$（士兵）。一开始，我当的是$\texttt{SB}$（哨兵）。苦差事啊，看见$\texttt{SB}$（上边）就要敬礼，一站几个钟头还不让看$\texttt{SB}$（手表），屁大的事情都要及时$\texttt{SB}$（上报），练站姿的时候还要挂个小$\texttt{SB}$（沙包），一天下来，连$\texttt{SB}$（散步）的力气也没有了。我就$\texttt{SB}$（随便）编了个理由说我$\texttt{SB}$（生病）想转去当$\texttt{SB}$（水兵），结果被分到一个$\texttt{SB}$（舢板）上，靠，就我那个$\texttt{SB}$（身板），把我晕得呀，连上个月会餐吃的$\texttt{SB}$（扇贝）、$\texttt{SB}$（烧饼）都吐出来了，额滴神呀，我$\texttt{SB}$（上辈）子做了什么孽啊。领导打算把我改去当$\texttt{SB}$（伞兵），我说我不去，这要是着陆不小心，$\texttt{SB}$（势必）就变成$\texttt{SB}$（伤兵）了，要是$\texttt{SB}$（手背）或者$\texttt{SB}$（上臂）受伤裹上$\texttt{SB}$（纱布），最多留个$\texttt{SB}$（伤疤），要是腿摔断，可就变成$\texttt{SB}$（孙膑）了，如果遇到$\texttt{SB}$（山包）$\texttt{SB}$（闪避）不及，那可真的$\texttt{SB}$（折本）了。于是，我干脆$\texttt{SB}$（收兵）不干了。当兵前后$\texttt{SB}$（三百）天，除了累得脸$\texttt{SB}$（刷白），什么也没有学到。去$\texttt{SB}$（上班）吧？我念书的时候也不认真，从来不带$\texttt{SB}$（书包）、不看$\texttt{SB}$（书本），现在连$\texttt{SB}$（鼠标）都不会用。只好去给人家看$\texttt{SB}$（水泵），我连$\texttt{SB}$（烧杯）都没有摸过，我哪懂？那个$\texttt{SB}$（设备），没有说明、没有$\texttt{SB}$（商标）也没有其它$\texttt{SB}$（识别）标记，噪音的$\texttt{SB}$（声波）在屋子里$\texttt{SB}$（散播），象$\texttt{SB}$（山崩）一样。突然，一个$\texttt{SB}$（事变）发生了，我$\texttt{SB}$（身边）的一块$\texttt{SB}$（石板）突然倒下了 人生就像动态规划，你的一个又一个阶段是由上天安排的。而你，决定的是在这一阶段可以由上一阶段的哪些状态转移而来。越勤奋，越幸运，并不代表这一次你决策的方向有多么优秀。却代表着现在的这一个状态能够续写多少可能的结果。 听说津津为课程烦恼 金明一家住进了新房听说丁丁玩数字游戏 火柴棒能搭出新天地听说校门外正在砍树 大家一起做靶形数独听说旅行者在赚差价 潜伏者正在破译着密码只有无尽的代码知道 津津摆脱了学习的烦恼金明开心地走进商店 挑选着书桌和电脑总有一种算法能够让你成功拿到分无论是贪心还是动规 或者将答案二分思如泉涌掀起波涛 又汇成一个新的算法让所有TLE 所有MLE 激励着我们前行写代码听说同学们在玩推理 小Z的袜子总配不齐听说两人在挑选客栈 火星上有条能量项链听说陶陶在采摘苹果 一只青蛙要从河边过听说推销员走入胡同 杰瑞爬进了奶酪的小洞只有无尽的代码知道 同学们男女配对练起了舞蹈小Z 把他的袜子找到 AK了无数机房深夜电脑,富丽堂皇,题目 W A ,不免彷徨.D P 背包,迷迷茫茫,R P R P ,全部用光.屏幕微亮,代码千行,灰名蓝名,淡淡忧伤…… 学校机房夜送客，枫叶蒟蒻秋瑟瑟。主人下马客在船，代码欲写无键盘。夜不 A C惨将别，别时茫茫屏幕亮。 忽闻楼上键盘声，主人忘归客不发。寻声暗问敲者谁，键盘声停欲语迟。上楼相近邀相见，添酒回灯重开宴。千呼万唤始出来，犹抱键盘半遮面。键盘打出三两字，未成算法先有情。代码掩抑注释思，似诉平生不得志。低眉信手续续弹，说尽心中无限事。轻拢慢捻抹复挑，初为《搜索》后《动规》。大写变量放局部，小写变量设全局。嘈嘈切切错杂弹，暴力五分钟写完。连续遍历二叉树，前缀之和取区间。出题套路都断绝，一道黑题瞬间切。别有状态转移生，此时无声胜有声。规律方程全汇总，边界特判输出 0。程序写完当优化，20个点0ms。大佬神犇悄无言，唯见机房屏幕白。 最后一题评测中，整顿衣裳起敛容。自言本是京城女，家在虾蟆陵下住。十三学得 O I成，名属一等第一部。编罢曾教大佬服，写成每被神犇妒。五所大学争风头，提交 A C不知数。常和蒟蒻颓slay，难题渐渐做不出。今年颓废复明年，秋月春风等闲度。C E R E T L E$\;$， W A声一片ACM。成绩爆炸忙退役，钻研算法不复出。 A C若即又若离，机房题库编程去。去来 C F守房间，机房屏幕颜色寒。夜深忽梦少年事，梦啼妆泪红阑干。 我闻键盘已叹息，又闻此语重唧唧。同是天涯沦落人，相逢何必曾相识！我从去年搞信竞，春夏秋冬练不停。D 1 D 2$\;$不会做， N O I P见祖宗。日日夜夜颓slay，无数蒟蒻绕宅生。其间旦暮闻何物？蒟蒻啼血机惨鸣。春江花朝秋月夜，往往 A C还独倾。岂无水题与红题？呕哑嘲哳难为听。今夜闻君键盘语，如听仙乐耳暂明。莫辞更坐写一题，为君翻作《键盘行》。感我此言良久立，却坐刷题 A C急。凄凄不似向前声，满座重闻皆掩泣。座中泣下谁最多？机房蒟蒻青衫湿。 我是新人，刚学OI，请问可持久化非确定状态AC自动分块维护线段平衡仙人掌优化最小费用最大流预处理混合图上莫比乌斯反演莫队带花舞蹈链并查集树状数组套主席树预处理动态DP分治FFT求多项式逆元对数函数的指数函数用可持久化并查集合并最小费用循环流上插头DP怎么写？ zhr一到机房，所有做题的人便都看着他笑，有的叫道，“zhr，你门前又长出主席树了！”他不回答，对老师说，“开两台电脑，要一堆毒瘤题。”便排出一堆AC代码。他们又故意的高声嚷道，“你一定又AK了人家的比赛了！”zhr睁大眼睛说，“你怎么这样凭空说人大佬……”“什么？我前天亲眼见你虐了DSY，吊着打。”zhr便涨红了脸，额上的青筋条条绽出，争辩道，“（0ms+AK）不能算AK……（0ms+AK）！……巨佬的事，能算AK么？”接连便是难懂的话，什么“我是神犇”，什么“DSY是蒟蒻”之类，引得众人都哄笑起来：机房内外充满了快活的空气。听人家背地里谈论，zhr原来也做我们做的题，但终于不屑于再做，又不会出这么水的题目；于是做的题愈做愈难，难到我一看就吓晕了。幸而做得所有题目，便替人家做水题，换一道神仙毒瘤题做。可惜他又有一样坏脾气，便是不屑于做。做不到几天，便连人和电脑程序代码，一齐失踪。如是几次，叫他做水题的人也没有了。zhr没有法，便免不了偶然做些AK神仙毒瘤比赛的事。但他在我们店里，品行却比别人都好，就是从不拖欠；虽然间或不屑于做我们的题，暂时记在粉板上，但不出一小时，定然全A，从粉板上拭去了zhr的名字。zhr做过几道神仙毒瘤题，涨红的脸色渐渐复了原，旁人便又问道，“zhr，你当真能（0ms+AK）么？”zhr看着问他的人，显出不屑、鄙视的神气。他们便接着说道，“你怎的连我们的题目也不刷光呢？”zhr立刻显出藐视嘲讽模样，脸上笼上了一层红色，嘴里说些话；这回可是全是“全是水题”之类，一些不懂了。在这时候，众人也都哄笑起来：机房内外充满了快活的空气。在这些时候，我可以附和着笑，老师是决不责备的。而且老师见了zhr，也每每这样问他，引人发笑。zhr自己知道不能和他们谈天，便只好向蒟蒻说话。有一回对我说道，“你会做A+B Problem么？”我略略摇一摇头。他说，“不会做，……我便考你一考。洛谷的深蓝题，怎样做的？”我想，这么大佬的人，也能考我么？便回过脸去，不再理会。zhr等了许久，很恳切的说道，“不会做罢？……我教给你，记着！这些题应该记着。将来打我出的比赛的时候，做题要用。”我暗想我和他的等级还很远呢，而且我也从不敢打他出的神仙毒瘤比赛；又好笑，又不耐烦，懒懒的答他道，“谁要你教，不是只有你才会做的题目么？”zhr显出极不高兴的样子，将两个指头的长指甲敲着键盘，点头说，“错啦错啦！……这些题目都是超级水的红题，你知道么？”我愈不耐烦了，努着嘴走远。zhr刚打了一堆毒瘤算法以及宏函数，想在IOI官网上AK，见我毫不热心，便又叹一口气，显出极惋惜的样子。有几回，邻居CYY和QY听得笑声，也赶热闹，拦住了zhr。他便给他们神仙毒瘤题，一人几十道。他们做完题，仍然不散，眼睛都望着他的个人题库。zhr着了慌，退出题目将屏幕锁住，弯腰下去说道，“太简单了了，这都太简单了。”直起身又看一看题目，自己摇头说，“简单简单！难乎哉？不难也。”于是这一群神犇巨佬都在笑声里走散了。zhr是这样的使人快活，可是没有他，别人也便这么过。有一天，大约是ACM World Final后的两三天，老师正在慢慢的算AC题目，取下粉板，忽然说，“zhr长久没有打我们的题了。还欠十九道题呢！”我才也觉得他的确长久没有打我们的题了。一个蒟蒻的DSY说道，“他怎么会打我们这些水题？……他打神仙毒瘤题去了。”老师说，“哦！”“他总仍旧是（0ms+AK）。这一回，是自己太强，竟（0ms+AK）到IOI里去了。IOI的神仙毒瘤题，（0ms+AK）得的么？”“后来怎么样？”“怎么样？先拉他去了ACM World Final比赛现场，后来是做题，做了几分钟，就直接（0ms+AK）了。”“后来呢？”“后来他（0ms+AC）完所有的神仙毒瘤题了。”“刷完了怎样呢？”“怎样？……谁晓得？许是去出神仙毒瘤题然后自己（0ms+AC）了。”老师也不再问，仍然不住地感叹zhr是历史上最强的神犇大佬。 骗分弄巧，爆零传恨，神犇AK暗度。枚举暴力一相逢，便胜却算法无数。 RE似水，CE如梦，忍顾超限归路。AC若是久长时，又岂在WA朝暮？ 如果26个英文字母A B C D E F G H I J K L M N O P Q R S T U V W X Y Z分别等于:1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 。那么： Knowledge (知识)：K+N+O+W+L+E+D+G+E11+14+15+23+12+5+4+7+5=96%。Work hard (努力工作）：W+O+R+K+H+A+R+D＝ 23+15+18+11+8+1+18+4 =98%。也就是说知识和努力工作对我们人生的影响可以达到96％和98％。Luck（好运） L+U+C+K＝12+21+3+11=47%。Love（爱情） L+O+V+E＝12+15+22+5=54%。看来，这些我们通常认为重要的东西却并没起到最重要的作用。 那么，什么可以决定我们100％的人生呢？是Money（金钱）吗？M+O+N+E+Y=13+15+14+5+25=72%。 看来也不是。是Leadership (领导能力)吗？ L+E+A+D+E+R+S+H+I+P=12+5+1+4+5+18+19+9+16=89% 还不是。金钱，权力也不能完全决定我们的生活。那是什么呢？其实，真正能使我们生活圆满的东西就在我们的代码里面！iostream(输入输出流所在的头文件)I+O+S+T+R+E+A+M=9+15+19+20+18+5+1+13=100%。所以安心打代码吧！ 小时候，OI愁是一份短短的CE，我在这头，编译通过在那头。 长大后，OI愁是一行模拟的WA。我在这头，AC在那头。 后来啊 OI愁是一张窄窄的奖状。我在这头，省一在里头。 现在啊 OI愁是一块轻轻的铁牌，我在这头， 高校在那头。 啦啦啦，啦啦啦，我是刷题的小行家。再难的题目也不怕。看题解，抄代码。今天的教练没吃药， 感觉自己感觉自己萌萌哒！ 啦啦啦，啦啦啦，我是考试的小行家。在坑的试卷也不怕。带U盘，上网查。今天的考官没吃药，感觉自己感觉自己萌萌哒！ 啦啦啦，啦啦啦，我是作弊的小行家。再狠的老师也不怕。带资料，抄学霸。今天的自己没吃药， 感觉自己，感觉自己萌萌哒！ 一遍又一遍地看着Tarjan 却还是不会缩点一次又一次地推着方程 却忘了断环为链Debug了一整天 才把断点发现寄存器中的数据间 自己早已不再是当年曾经骄傲的剪枝深搜 放在现在只能算暴力那些打得熟烂的模板 可能是过去的奇迹C++从入门到放弃 一直妄图终结掉DP或许他进国决他却退役 但const一起的记忆记忆回溯那时的往昔 我们还只会打打暴力还未想过什么NOIP 更别说省二省一忘不掉提交记录中的RE 还有那SE、CE、UKE O、M、T的LEWA声中终于A了一道题 是多么的欢喜我们看着小鱼干dalao的笔记二分图匈牙利 数据离散哈希我们惊叹：哇塞这都是什么东西曾以为数论只有GCD 一棵线段树便让我们膜拜到底现在想起 这些曾以为遥不可及的东西增多了亲切与熟悉 带着麦芽的香气我们说要认真学习 电脑上却打开了游戏我们回到B站看视频 假装心中有SBT永远追随珂朵莉 保佑我写出STD裸装深渊不保级 只为增加点RP考场不能naive 三罐维他出奇迹本命质数防卡模 七二二一四五七队列起名叫RP 是我们的玄学物品高三考完就退役 多了些悲欢合离依稀记得Flag：一定要拿省一 洛谷比赛风怒号，卷我蒟蒻三重茅。WA渡江洒热泪，神犇挂罥全AC，蒟蒻飘转TLE。南村群神犇欺我蒟无力 忍能对面得Au，公然AK入省队。唇焦口燥呼不得，刚回来爆零自叹息。俄顷提交血红色，万籁俱寂都昏黑。鼠标多年冷似砖，键盘乱按健里裂。WA屋漏无干处，CE如麻未断绝。自经WA少AK，TLE全屏何由彻。大庇天下神犇俱欢颜，评测机不动安如山。呜呼，何时A题记录全是绿 唔AC率全掉亦足。 秀天秀陈独秀蒂花之秀造化钟神秀李大钊陈独秀维多利亚内衣秀吾何时能及汝之秀同福客栈李秀莲的秀我滴龟龟你怎么这么秀李云龙老婆秀芹的秀求求你了不要再秀米兰国际时装秀湖南台真人秀中国梦想秀山清水秀年代秀刘秀秀 跪跪跪跪跪跪 跪跪跪跪跪跪跪跪跪跪跪跪跪跪 跪 跪 跪跪 跪 跪 跪跪 跪 跪 跪跪跪跪跪跪 跪 跪跪跪跪跪 12345678 \_\__/_/\|\_\/_/|/ _ |○| |○|___| |○○| |_____ /_/||\_\ | | | | / / \ \ 顶要顶必须顶不得不顶用尽全力顶再加上千斤顶总之把它顶到顶接着使出葵花宝顶就算顶到史前也要顶老子看了会用道德经顶孔子亲自拜我为师天天顶秦始皇站在阿房宫上使劲顶汉高祖挥师杀向东罗马为我顶吕布抛弃了貂禅而选择了帮我顶张三丰见了后用太极拳九式全力顶左冷禅召开武林盟主大会商讨如何顶西门吹雪从此学会了最强一招剑神一顶龙剑飞的如来神掌最后一式改为万佛朝顶陆小凤从此再也不管闲事了而专门来为我顶四大名捕四面出击看天下还有没有人敢不在顶黄飞鸿的宝芝林里从此多了一味药叫做吃了就顶霍元甲其实根本就没有死因为他还想要努力帮我顶蒋介石之所以秃了顶就是因为天天晚上在费力为我顶希特勒消失在人们的视线当中其实是在暗地里不断地顶爱因斯坦宁愿自已把相对论彻底的否定也要来为我顶一顶萨达姆成了亡国奴可是一直到现在都没有屈服而在拼命的顶本拉登在曼哈顿不小心放了两个大花炮现在只能躲起来为我顶小泉这厮本来不想让他顶但他有这么厚脸也没办法只能让他也顶小布什调集了全球美军所有的战斧式巡航导弹向华盛顿发射来狂顶阿扁的腿已吓得发颤大小便也已经失禁却还要硬着头皮说我就是要顶外逃的贪官们已被抓回了一大批但还有一些心存侥幸的家伙在想办法顶张艺谋为了表达心中对你的感慨而去专门拍了一部片子大红灯笼高高挂顶超级女声的名头越来越响但实际上在她们内心的世界里只爱我一人只为我顶姚明竭尽全力在总决赛第七场的最后一秒高高跳起不为了扣蓝而是为了帮我顶乔丹在蓝球场上之所以这么伟大是因为他在多年前就预感到了伟大的你而为我顶贝克汉姆在一场比赛里踢出了一百个香蕉球都被对手奋不顾身的往自家的球门里顶国际乒联为了取悦于我而彻底的将乒乓球击球的规则由向前拍打改为只准用拍向前顶全国人民代表大会所有委员一致通过将你的精神写进宪法让全国人民来一起围着我狂顶所有的这一切都是你再世卧龙在背后所精心策划的为了让我能够光宗耀祖而煞费苦心的顶 跟着我左手右手一个生成树右手左手一片网络流朝我题解会爆零你有没有恨死我 跟着我暴力枚举来个TLE空间换时间是MLE代码有太多，未知的猜测停止工作算什么 键盘擦亮，鼠标擦亮屏幕深夜发着光在最短路，上面彷徨无向图给我力量 这OJ的机器让我看着她叹息这比赛的算法有我才能对 拿到题目第一句，骗分打表过样例。 多打一个return 0，都要说声对不起。 文件搜索告诉我，答案文件在哪里。 暴力、搜索枚举，我要百分十数据！ search search我要百分十数据！ search search为了Hack掉rank 1， 对拍卡炸cmd。为了调过数学题， 手算算废墨一瓶。自带二分难自弃， 可惜模板我打不起。暴力、搜索枚举， 我要百分十数据！ 呜~~~TLE MLE REOLE UKE PETLE MLE REOLE UKE PEWA变PC变AC!卡炸我的编译器！ 拜拜，GCC，Python Java C17， Pascal C# C11，废物语言别客气。 拜拜，cmp，戒掉哈希戒掉Tree， long double会TLE,别再卡常伤身体。 先是C再++一看时间二看练白天想夜里哭做梦都想拿金牌俩脚离地了竞赛就成功了啥都拿不到了嚎，嗷OI春风吹满地吹满地春风吹满地洛谷谷民真争气真争气谷民真争气这个世界太疯狂数学都给OI来瞎搞线性筛杜教筛线性的杜的杜教筛记得那是2018年的第一场月赛第一场月赛比2017年的来得稍晚了一些稍晚了一些看题审题写题交题WA知道因为啥WA吗真让我替你感到悲哀不骗分 不打表坐着就是刷水题用水题的方式 这叫水疗现在请看今天的模拟题NOI2018的第一套模拟放错题了评测都过了WA被赶跑选手安居乐业齐夸CCF领导数竞比较糟糕成天建立坐标纵观竞赛风云题目这边更好线段树的心呐线段树的情线段树的ltt它透着心里红线段树的kkk请你多批评封禁啥 那是暴政OI春风吹满地吹满地春风吹满地洛谷谷民真争气真争气谷民真争气这个世界太疯狂数学都给OI来瞎搞线性筛杜教筛线性的杜的杜教筛CZ暴切我虐待我AK我他不光吊打我关键是 他吊打集训队啊TLE MLE OLE交一下洛谷 WA感谢学校感谢所有学校床前明月光清清楚楚要暴零最短路 生成树main包main包那叫巨不骗分 不打表坐着就是刷水题用水题的方式 这叫水疗现在请看今天的模拟题NOI2018的第一套模拟放错题了评测都过了WA被赶跑选手安居乐业齐夸CCF领导数竞比较糟糕成天建立坐标纵观竞赛风云题目这边更好 徘徊着的，在刷题的你要写吗，via，via疯狂的，骄傲的那也曾是我的模样 被禁言的，被封号的你要去哪，via，via谜一样的，沉默着的故事你真的在听吗 我曾经当过红名神犇也受过万人敬仰我曾经拥有这一切转眼都飘散如烟我曾经一周不登洛谷不在刷题直到看见蓝名才是唯一的答案 而我仍然，还在幻想我的明天，via，via我会红吗，还是掉灰对我而言是最重要的 我曾经幻想我会变红只想永远地强大我曾今沉迷收集模板想挣扎无法自拔我曾经像你像他像那普通用户绝望着，渴望着，哭着笑着奔跑着 敲代码，就这样敲，哪怕不是AC就是WA写DP，还写贪心，就算是PC和CE写DFS，还写暴力，就算我会RE和TLE狂模拟，爱上高精，就算你会 我曾经当过红名神犇也受过万人敬仰我曾经拥有这一切转眼都飘散如烟我曾经一周不登洛谷不在刷题直到看见蓝名才是唯一的答案 我曾经幻想我会变红只想永远地强大我曾今沉迷收集模板想挣扎无法自拔我曾经像你像他像那普通用户绝望着，渴望着，哭着笑着奔跑着 A：「初赛难吗？」B：「难炸了，我退役吧。」A：「有多难？」B：「这么说吧，您玩过三国杀吗？」A：「玩过。」B：「如果牌堆无限，甄姬洛神一次期望得到几张牌？」鸦雀无声。。。 全国青少年计算机程序设计大赛究竟何时创办？前缀与后缀为何混淆不清？Catalan数到底表示什么？是什么让一台只有红蓝两色球的抽奖机如此火爆？关机的手机究竟能否带进考场？负权回路与Dijkstra算法有什么不为人知的关系？图灵奖到底是哪方设立？四人郊游为何只有两人如约？是什么让++cnt陷入无意义的循环？双向链表究竟是何方神圣？小猪又为何在两家商店间因巨额消费徘徊不定？这究竟是人性的泯灭还是道德的沦丧？敬请收看今日说法特别节目：第24届全国青少年计算机程序设计大赛。今晚8点，CCTV12法制频道准时播出。 陈独秀同志，请你坐下。你这种行为挡住了旁边的李大钊同志发言。这让胡适同志很难受。令鲁迅同志很难堪。朱自清同志表示很尴尬。钱钟书和徐志摩同志已经在撸袖子了。所以，为了你的生命财运亨通，请默默坐下，低调做人。你凳子上的钉子我已经给你拔掉了。凳子底下的地雷我也给你挖出来了。对面楼上的狙击手也被击毙了。下水道里的特务也被淹死了。现在能不能坐下来了？。 chen_zhe同志，请你坐下。你这种行为挡住了旁边的老K同志发言。这让yyy2015c01同志很难受。令soha同志很难堪。Himself65同志表示很尴尬。lin_toto和kkksc03同志已经在撸袖子了。所以，为了你的生命安全，请默默坐下，低调做人。你凳子上的钉子我已经给你拔掉了。凳子底下的地雷我也给你挖出来了。对面楼上的狙击手也被击毙了。下水道里的特务也被淹死了。现在能不能坐下来了？ 我能抽象出整个世界，但是我不能抽象你。想让你成为私有常量，外部函数无法访问你。又想让你成为全局常量，在整个生命周期随时都可以调用你。因为世界上没有这样的常量，所以我无法定义你。 你在我心中是那么的具体。我可以重载甚至覆盖这个世界的任何一种方法，但是我却不能重载对你的念。也许命中注定了你在我的世界里永远的烙上了静态的属性，而我不慎调用了爱你这个方法。当我义无反顾的把自己作为参数传进这个方法时，我才发现爱你这个方法是一个死循环，它不停的返回对你的思念压入我心里的堆栈。 在这无穷无尽的循环中，我的内存已经快消耗殆尽。我却依然不停的向系统申请空间换取我对你的思念。我愿意虚拟出最后一点内存，把所有我能实现的方法地址压入堆栈。并且在栈尾压入最后一个方法：如果返回值为真—我将用尽一生去爱你，否则—我将释放掉所有的系统资源。 唧唧复唧唧，木兰开飞机。开的什么机？波音747！问女何所思，问女何所忆。女亦有所思，没钱买飞机。昨夜见军帖，要用轰炸机。飞机十二架，架架买不起。阿爷无大钱，木兰无金银。愿去买钢铁，从此造飞机。东市买图纸，西市买螺丝。南市买玻璃，北市买铁皮。旦辞爷娘去，暮宿旧机库。不闻爷娘唤女声，但闻铁皮摩擦滋啦啦。旦辞机库去，暮至军营旁。不闻爷娘唤女声，但闻将军大呼哈哈哈。万里开飞机，关山一下没。热气传机翼，日光照玻璃。将军被吓死，壮士魂已飞。飞来撞天子，天子躺病床。策勋十二转，赏赐俩耳光。可汗问所欲，木兰不愿进牢房。愿开747，飞着回故乡。爹娘闻女来，端起机关枪。阿姊闻妹来，当户举手枪；小弟闻姊来，磨刀霍霍向智障。开我机舱门，进我飞机舱，脱我战时袍，换上飞行装。多装手榴弹，对外架机枪。出门埋炸弹，亲友皆惊忙。离别十二年，不知木兰变猖狂。疯子脚蹬地，呆子眼紧闭。两人并排走，谁能说我不正常？ 君不见，洛谷之题天上来，复杂到海不舍回。君不见，高堂明镜悲白发，朝如青丝暮成雪。人生WAWA须尽思，莫使电脑空对题。天生我材没有用，千方百计还RE。AC一点且为乐，会须一刷三百WA。吾团友，牛大佬，将刷题，手莫停！！！与题做一遍，请系统为蒟蒻以测评。天天WAWA不足贵，但愿长眠不复醒！！！古来大佬皆刷题，惟有蒟蒻水水水。站长昔时百AC，斗题十千恣欢谑。主人何为言AC？径须沽取对君WA。TLE，MLE，OLE，UKE，WA，PC，CE和RE呼儿将出换AC，与尔同销万古愁！！！！ 语文老师一回头， 鲁迅甘为孺子牛。数学老师一回头， 六元六次都能求。英语老师一回头， 满口洋文跑地球。物理老师一回头， 一根杠杆撬地球。化学老师一回头， 二氧化碳变汽油。劳动老师一回头， 破铜烂铁来走秀。体育老师一回头， 黛玉也能踢足球。政治老师一回头， 全班同学都梦游。美术老师一回头， 蒙娜丽莎也风流。信息老师一回头， 带着学生玩网游。九科老师齐回头， 八大行星撞地球。 一天地理老师问：同学们，河水向哪里流呀？一学生猛站起来唱到：大河向东流啊。 老师没理会他，接著说：天上有多少颗星星啊？那位同学又唱到：天上的星星参北斗啊。 老师气急：你给我滚出去！学生：说走咱就走啊。 老师无奈说：你有病吧？学生：你有我有全都有啊！ 老师：你再说一句试试…学生：路见不平一声吼啊！ 老师：你信不信我揍你？学生：该出手时就出手… 老师怒：我让你退学！学生：风风火火闯九州！ 一名逃学的学生被抓了回来。老师问：为什么要逃学？学生回答：因为伙食太差了。老师又问：那你是用什么工具撬开学校的铁门的？学生答：$\color{red}{\text{早上的油条}}$。 屏幕在深夜微微发亮思想在那虚树路径上彷徨平面的向量交错生长织成 忧伤的网剪枝剪去我们的疯狂SPFA 告诉我前途在何方01 背包装下了忧伤笑颜 洋溢脸庞键盘微凉 鼠标微凉指尖流淌 代码千行凸包周长 直径多长一进考场 全都忘光你在 OJ 上提交了千百遍却依然不能卡进那时限双手敲尽代码也敲尽岁月只有我一人写的题解凋零在 OJ 里面Tarjan 陪伴强连通分量生成树完成后思路才闪光欧拉跑过的七桥古塘让你 心驰神往队列进出图上的方向线段树区间修改求出总量可持久化留下的迹象我们 伏身欣赏数论算法 图论算法高斯费马 树上开花线性规划 动态规划时间爆炸 如何优化我在 OI 中辗转了千百天却不让我看 AK 最后一眼我用空间换回超限的时间随重新编译测完样例才发现漏洞满篇原来 CE 是因选错语言其实爆零 只因忘写文件如果标算太难请坚定信念不如回头再看一眼题面以那暴力模拟向正解吊唁蒟蒻的蜕变神犇出现终将与 Au 擦肩屏幕在深夜微微发亮我心在考场 AC: Answer Accidently 意外的答案CE：Compile Easily 轻松地通过编译PC：Past Compile 通过编译WA：Wonderful Answer 极好的答案RE：Right Enough 太过正确TLE: Time Limit Enough 时间充裕MLE: Memory Limit Enough 内存充裕OLE：Output Limit Enough 输出充裕UKE: United Kingdom Error 大不列颠错误 有的人以为作业写完了，但其实还没写完；有的人以为假期没结束，但其实已经结束了。 有的人把作业压在学生头上：“呵，我多牛！”有的人俯下身子撕掉所有作业。 有的人把作业刻入黑板，想“不朽“；有的人一把火过去，学生的作业被烧。 有的人他活着学生就会累死；有的人他活着是为了帮学生抄作业。 把作业压在学生头上的学生把他摔垮；帮学生撕作业的学生永远记住他！ 把作业刻入黑板的作业比尸首烂得更早；只要火把烧到的地方到处是作业的渣渣。 他活着学生就会累死他的下场可以看到；他活着为了帮学生抄作业学生把他抬举得很高，很高…… 天若有情天亦老，我为暴力续一秒。比赛时节家家雨，OI赛场处处 W A。浔阳 D P无音乐，终岁不闻 A C声。莫愁前路无 RE ，天下谁人不 W A。天生我材没有用，千方百计还 R E。 A C一点且为乐，会须一刷三百WA。山重水复疑 R E，柳暗花明又 W A。不开long long见祖宗，多年OI一场空。 数学是火，点亮物理的灯；物理是灯，照亮化学的路；化学是路，通向生物的坑；生物是坑，埋葬学理的人。 文言是火，点亮历史宫灯；历史是灯，照亮社会之路；社会是路，通向哲学大坑；哲学是坑，埋葬文科生。 世有学霸，然后有附加题。附加题常有，而学霸不常有。故虽有难题，祗辱于学渣之手，骈错与红叉之间，不以全对称也。 题之附加者，一题或难倒一片。做题考不知其能加分而做也。是题也，虽有附加之能，做不对，分不加，才美不外见，且欲与常规题等不可得，安求其能加分也。 模拟只会猜题意，贪心只能过样例。数学上来先打表，规律一般是DP。 组合数学碰运气，计算几何瞎暴力。图论一顿套模板，数论只会GCD。 递归递推伤不起，搜索茫然 T L E。分治做得像枚举，暴力枚举数第一。 数据结构干瞪眼，怒刷水题找信心。涨姿势也不容易，考试一来全懵逼。 写字楼里写字间，写字间里程序员。程序人员写程序，又拿程序换酒钱。 酒醒只在网上坐，酒醉还来网下眠。酒醉酒醒日复日，网上网下年复年。 但愿老死电脑间，不愿鞠躬老板前。奔驰宝马贵者趣，公交自行程序员。 别人笑我忒疯癫，我笑自己命太贱。不见满街漂亮妹，哪个归得程序员？ 字典树上字典游，字去树空网络流。插头 D P打暴力，洪水填充码读优。三维凸包深搜外，二分图中用树剖。总为缩点能 A C，贪心满分使人愁。 暴力碾标算，n 方过百万。乱搞出奇迹，骗分最神奇。 您强归您强，神牛漫山岗。您巨归您巨， OI 照大江。 双旋的splay，单旋的spaly。不旋的saply，O(1)的asply。 经过犯罪嫌疑人长达一个晚上的审问，王警官说出了刑警大队所有的秘密。王警官与犯罪嫌疑人进行长达两个多小时的周旋最终，二人被管理员赶下旋转木马。经过一整晚的审讯，经验丰富的王警官收获颇丰，终于从犯罪嫌疑人郝某的口中得知，他有三处口腔溃疡与一处蛀牙。案发现场惨不忍睹，杀人凶手的手法极其残忍，经验不丰富的实习警员小李已经是双腿发软，因为第一次执行任务的他万万没有想到，还要负责背着吓晕的王警官。为了能尽快查出这起凶杀案的真凶，经验丰富的王警官考虑再三，决定赶紧退出不再掺手此案。刑警大队的会议上，经验丰富的王警官对案件的分析十分详尽，配合他自己精心制作的PPT，分别从犯罪嫌疑人的作案手法，以及犯罪现场的盘查取证，与法医鉴定报告等多个方面，阐述了自己为什么破不了这个案子。正当对犯罪现场侦查完毕将要离开之际，经验丰富的王警官突然发现了地上的一个烟头！要知道，根据死者家属的描述，死者生前并不抽烟。面对这个重大发现，他立即命令经验不丰富的实习警员小李对此展开调查。小李接到命令后说：这不是刚才你在这抽的吗？经验丰富的王警官观察一番后说道：“门和窗都是从里面反锁的，而死者头破血流伤痕累累，显然不是自杀，所以，这无疑是一桩典型的密室杀人案！” 同行的几名年轻警员听完他的分析也是目瞪口呆，最后忍不住将他带离了车祸现场。经验丰富的王警官咬了一口粽子，便立刻发觉味道不对！办案多年的他深知自己已与黑道势力结下怨恨，所以第一反应就是大事不妙，一定是自家的粽子会被人做了手脚。但他沉着冷静，仔细揣摩粽子味道的异常，终于发现其中的蹊跷，原来是吃的太着急忘了剥粽子叶。向来配合默契的经验丰富的王警官与经验不丰富的实习警员小李却因观点不同发起了争执。王警官认为：死者虽然处于密闭环境，但身上缠有绷带，显然不是常规的密室杀人案，应该是重伤之后又被人放置于密室之中，但是小李却认为，王警官不应该在单位组织去埃及金字塔旅游是说这些有的没的？面对法医的鉴定报告，王警官陷入了沉默，思考了很久才开口说话：“你写的啥几把字？”看完尸验报告，王警官表情凝重，深深吸了一口烟说：“看来要找到真凶不是一件容易的事…因为死者已经隆胸有二十多年了…”王警官像往常一样加班到深夜独自回家，半路被突然窜出来的一群人团团围住，并威胁他以后不要再掺手眼前这起他负责的凶杀案。而经验丰富的王警官对这种情况早就习以为常，他沉着冷静，呵呵一笑，还是毅然决然地拒绝了同事们的请求。王警官来到犯罪嫌疑人家中的时候已经是人去楼空。但经验丰富的他没有立即出去追赶，二十走到床边，摸了摸被子，发现被子还是热的。这才会心一笑，放心地钻进被窝，愉快地睡了起来。虽然为了尽早破获这起起手的案件，刑警大队已经几天几夜没有合眼，但还是没有什么进展。这是，幸好官及时出马，用他精彩的推理，使得大家睡了一个好觉。起初，新来的年轻警员都不太理解，王警官去犯罪现场执行任务前为何总是会让助手帮他带上两个崭新的塑料袋。而经过几次合作后才终于发现其中的端倪，原来是因为王警官晕车。为了能尽早得知凶手是谁，经验丰富的王警官加班后回到家里，都没顾得上休息一会儿，就有独自把自己关在书房里，迫不及待地看完了后半集的剧场版名侦探柯南。王警官第一时间赶到犯罪现场，但是经过仔细盘查，并没有见到报案电话中群众所说的尸体。莫非是有人毁尸灭迹？王警官沉思片刻，便会心一笑，对同行的警员下令说：“给我追！尸体一定跑不远！”面对复杂的卷宗，经验丰富的王警官表情凝重，一连抽了几包烟，不是咳嗽。经验不丰富的实习警员小李看不过去前去劝阻。王警官解释道：“放心我没事，多年破案的老毛病…不抽就没有灵感…”小李听后说：“虽然我经验没您丰富，但如果您真把我当朋友，就听我一句劝，别抽我的烟了行不？”王警官与他饲养对年的警犬大壮配合十分默契，仅用半个小时不到，就把食堂的酱肘子吃的连骨头都不剩。王警官带领队员闯入犯罪嫌疑人家中，经验丰富的他直奔卧室，摸了摸被子对大家说：“被窝还是热的！罪犯一定还没跑远！”话音刚落，就吓得罪犯钻出了被窝。面对歹徒手中的水果刀，经验丰富的王警官早有准备，从容地拿出了水果。面对法医的坚定报告，王警官会心一笑：呵呵，果然和自己之前料想的一样，还是看不懂。正当案件一筹莫展时，法医的鉴定报告及时送到。看过之后，经验丰富的王警官顿时觉得这起难解的凶杀案变得简单了不少，因为他认为，破案可起码比他妈的认出法医的字容易多了。王警官用坐井观天造句：我做警官天天都很开心。听闻歹徒穷凶极恶，王警官坚持要带枪行动。但同行警员纷纷劝说他这样容易暴露行踪，最终王警官也只好作罢，不得不把祖传红缨枪留在了办公室里。王警官接到了一个非常棘手的案子，已经用光了三瓶护手霜。经验丰富的王警官与经验不丰富的实习经验小李，虽然合作时间不长，但二人的配合已经相当默契。就拿最近的这起凶杀案来说，他们仅用了不到两天的时间，就同时选择了放弃。虽然罪犯显然是对案发现场进行过处理，但经过一番仔细侦查，经验丰富的王警官还是从一些蛛丝马迹中判断出，自己又去错了案发现场。我市刑警大队有两人离奇失踪，机智的王警官进单位改名为“刑警一阝”，令人佩服。经验丰富的王警官经过对案发现场的盘查后说：“你们有没有发现，这个案子与两个月钱朝阳区$\texttt{KTV}$包厢密室杀人案和一周前东城区电子厂跳楼案以及三天前的海淀区出租房碎尸案有个惊人的共同点。”经验不丰富的年轻警员恍然大悟：“您的意思市售这是一个连环杀人案？”王警官说：“不是，我的意思是说我都破不了。” 无根树，有根树，搜索树，线段树，辞旧岁琼枝玉树；有向图，无向图，拓扑图，连通图，迎新春大展宏图。 望江楼，望江流，望江楼上望江流，江楼千古，江流千古；查找树，查找数，查找树中查找数，找树万层，找数万层。 《算法导论》论算法；《朝花夕拾》拾朝花。 从入门到入土从送分到送命 小A被绑匪劫持到了山洞里，绑匪说：“你tm要是能给我在3秒钟之内算出2^47-1等于多少，我就放了你。”话音未落，小A就答道：“0x7fffffffffffll。”绑匪给小A松了绑，流泪说道：“唉，我以前也是程序员，做这行的，不容易啊……” 刷题是一种出路枚举是一种思想打表是一种勇气搜索是一种信仰剪枝是一种精神骗分是一种日常爆零是一种宿命W A 是一种绝望TLE 是一种痛苦R E 是一种放弃UKE 是一种无奈A C 是一种原谅A K 是一种希望弃赛是一种颓废吊打是一种必然进队是一种奢望NOI是一种梦想 洛谷验证码：]]></content>
      <tags>
        <tag>其他</tag>
        <tag>娱乐</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[我的洛谷生涯]]></title>
    <url>%2F2019%2F10%2F05%2Fluogu%2F</url>
    <content type="text"><![CDATA[在这里，你能看到我在洛谷的点点滴滴，以及关于洛谷的一些东西。 我洛谷几个纪念性的日子被kkk回复了，虽然是检讨 仿假的洛谷 信 犇第一次被$\texttt{chen_zhe@}$啦，好激动一天后再次被$\texttt{chen_zhe}@$。还是被强烈资瓷被文文新闻的主编$\texttt{@}$关于戳泡冒泡管理员全屏AK IOI（没F12，没PS）大型jc现场一群巨佬啊 猫洛谷的猫洛谷的猫（讨论版 句洛谷定律&amp;名词 楼自建高楼 盗墓发现专炸管理员 noip ComeIntoPower zcysky darkflames kkksc03 扩散性百万甜面包 lin_toto 老K yyy2015c01 chen_zhe 阮行止 龟龟号打捞船 yjjr Anguei mcfx memset0 hh0592821贴洛谷最高楼专炸管理员说句闲话2洛谷评论报蒟扯1蒟扯2犇犇茶馆的故事今日说法文文新闻文文新闻整理不装弱大佬1不装弱大佬2kkk的忠告反对管理员怼管理员针对kkk 1针对kkk 2kkk的三大神器kkksc欺负人反对cz反对cz反对cz举报cz陈乙己noi的本质slay我做了一些不对的事情当众虐狗针对yyy2015c01面包姐姐的检讨即可科技为了我骂月赛怼洛谷怼灌水区怒怼洛谷假如洛谷4今天来临假如你遇见了chen_zhelin_toto的黑历史洛谷早期神贴管理员被盗号如何成为管理员怼比赛被爆破推广洛谷真·大佬装弱你谷小学生时事点评神奇提交斐波那契OI生命的结束红名如何倒着排序关于重题谁是洛谷最可爱的妹子洛谷特产CZ的暴政神仙打架神仙打架头像舌尖上的洛谷神贴整理1神贴整理2神贴整理3神贴整理4 与QWQ自动机的纠缠求助大佬本机正常提交RE求助求问各位大佬，自己运行没问题，云端评测却是REudebug上评分最高（26up）的数据是错的 员darkflames的小号是dark_test扩散性百万甜面包的小号是Himself65 题神题（超级无敌鬼畜毒瘤题）假神题]]></content>
      <tags>
        <tag>其他</tag>
        <tag>洛谷</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[随机图福利]]></title>
    <url>%2F2019%2F10%2F05%2Fpicture%2F</url>
    <content type="text"><![CDATA[在这里，你能看到很多随机图这里还有一张图片，请慎点]]></content>
      <tags>
        <tag>其他</tag>
        <tag>娱乐</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何初始化电脑]]></title>
    <url>%2F2019%2F10%2F05%2Fcomputer%2F</url>
    <content type="text"><![CDATA[在这里，讲述了如何初始化电脑 如何初始化电脑网络相关 默认网关改成10.196.1.254 枪毙学生端 浏览器相关 显示书签栏 把自定义字体改成自己喜欢的字体 桌面相关 把资源管理器，VS-code，Dev-cpp等东西锁定至任务栏 把开始菜单隐私一栏两个框改成不选 重命名任务管理器 开数字锁定 设置密码 VS-code相关要安装的插件 Chinese (Simplified) Language Pack for Visual Studio Code C++ Intellisense C/C++ Markdown All in One Markdown Preview Enhanced Games Opacity 设置 默认Shell改成Powershell 设置中Detect Indentation不勾选 设置中Editor: Insert Spaces不勾选 设置中Mouse Wheel Zoom勾选 设置中Minimap: Enabled不勾选 设置中Render Whitespace选成All 设置中Color Theme选成自己的主题 设置中Winopacity: Opacity选择透明度 Dev-cpp相关 编译器属性的缺省源取消 编译器属性中的代码补全延时设为1ms 编译器属性中的自动保存开启，间隔时间设定 编译器属性中的主题自选 编译属性的代码警告选成显示最多警告信息]]></content>
      <tags>
        <tag>电脑</tag>
        <tag>其他</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[搭博客]]></title>
    <url>%2F2019%2F10%2F05%2Fhow-to-build-blog%2F</url>
    <content type="text"><![CDATA[function doDecrypt (pwd, onError) { console.log('in doDecrypt'); const txt = document.getElementById('enc_content').innerHTML; let plantext; try { const bytes = CryptoJS.AES.decrypt(txt, pwd); var plaintext = bytes.toString(CryptoJS.enc.Utf8); } catch(err) { if(onError) { onError(err); } return; } document.getElementById('enc_content').innerHTML = plaintext; document.getElementById('enc_content').style.display = 'block'; document.getElementById('enc_passwd').style.display = 'none'; if(typeof MathJax !== 'undefined') { MathJax.Hub.Queue( ['resetEquationNumbers', MathJax.InputJax.TeX], ['PreProcess', MathJax.Hub], ['Reprocess', MathJax.Hub] ); } } U2FsdGVkX19sDeicr1kQz5TFaDNsdAN7VlblD/XLkq+Dg0+9j9BYO1FN9iLKCDFCp9a718hH3+Ptrfd9pEYHvCJHqTHS+x1tqJTPMsy5+CmgfFRRmP2000PZztbNqUxCERt+zbg4W0dh7jKcVbKDE4GFPu5n8B4YM+A5YD/patr4Mqzrbab0/jD3Sd22T6nY7XFwNtaVEQHgVJzOknsIek5D1HEyQQYPyDEMWCXxe6Xp65v7XTcAQfw/PTuoFZMBpjB1eeXGfT66+iWznrShUNyi0y4Ufe/CnZD4VC3oeUJ13+gaFyBLQfTOwIxwDsJs/7rSeQjVDvUHlLzHxSZLT07+rIBi1R+2yw9u8x5Hy2ccs/jxn+mtAZ/MIVvT2uXTBQ3kX8hC9UsPP42jwysTCivJvOaQtPVShr99GaiJMotPOx81EcvB0JuqIhq7t8cuhaoiYkMMGpEKaMpEf1D1BeGhL5Hozd3Jah34rVl/S80K4vTLyiWyKg8i9IOzVFZtCAny+ShfEOhYrzk4sK/xz5Rd2AZWrwDITS4qqRGRsAKZx49DUTLoy2c1jC6dwsF9QBeP2N5KTgAZEJ2k8WXm/GxiC6SbaqfAm9oQP8KqlTA+EBUFF0fMdidl3T2nBRNF0bqrb1TPr0ucV/K6aL9jTSprwaaMJHtws3PgA1BACYDC7OSdUdqWF5NXcW9RNcJEN7DGOcXitNNx7/XBo9pMs59+YK2Jd2OuKt+ig4PtZU9T8o2Ls4iImV3Bi73pwXG2RSm3zMqJ5m9RRT7yV8mDq9SNIZt69Ot8MfPY57JYosPJ6bPHWryv2wHWgse56jGFkhM05kU2V2axEtfCownELCrncfrVXqM/SlSFIpZ+WeIQFLytOXQbrbRK5rHbAjtHuQHAkBfreTMN5APgfs4D/oxyQCeaj5JIVISw2muyD6wRPU2vDwUzVYBF2MBw20V8NsgvLpSMv5LLXU7sMSWRp3i0BYoA4wESfPck9oILQTRV6UFq628XMkS6WOVa29wFty/QaVSwt81D61kkGV+isIIRcQiFOsCUw0uHFgKYQW1xLxD/0WlBvO+e1mMlyKWzqNwrZNyIVuG+4cWac+K1vtfRkmjddDV+9UJb5SCS6HgjxDT3htrmDQ92Paay0AAm8lw5v4QnEEFm+O+OJuyLQ7EZMewOA/srjhkVIPkW++CL67SUM1ANgAquFu1fLJ+B+a8MhuTcRfrrSevTdRupmz5UyrlmJjVkVraPogZ1mKL+X/d8f1nfMAmCuLBgC8mt var onError = function(error) { document.getElementById("enc_error").innerHTML = "password error!" }; function decrypt() { var passwd = document.getElementById("enc_pwd_input").value; console.log(passwd); doDecrypt(passwd, onError); }]]></content>
      <tags>
        <tag>博客</tag>
      </tags>
  </entry>
</search>
